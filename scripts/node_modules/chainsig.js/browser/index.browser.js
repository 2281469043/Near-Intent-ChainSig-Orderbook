import {base58}from'@scure/base';import Kt from'elliptic';import Ut from'js-sha3';import {keccak256,concatHex,numberToHex,getAddress,serializeTransaction,parseTransaction,toBytes,hashMessage,hashTypedData,encodeAbiParameters,hexToBigInt,concat,pad,isAddress}from'viem';import {hashAuthorization}from'viem/experimental';import*as h from'bitcoinjs-lib';import Ht from'coinselect';import {encodeSecp256k1Pubkey}from'@cosmjs/amino';import {sha256,ripemd160}from'@cosmjs/crypto';import {fromHex,toBase64,fromBase64}from'@cosmjs/encoding';import {Registry,encodePubkey,makeAuthInfoBytes,makeSignDoc,makeSignBytes}from'@cosmjs/proto-signing';import {calculateFee,GasPrice,StargateClient}from'@cosmjs/stargate';import {bech32}from'bech32';import {SignMode}from'cosmjs-types/cosmos/tx/signing/v1beta1/signing';import {TxRaw}from'cosmjs-types/cosmos/tx/v1beta1/tx';import {chains,assets}from'chain-registry';import {PublicKey,Transaction,SystemProgram}from'@solana/web3.js';import {Ed25519PublicKey,Deserializer,MultiAgentTransaction,SimpleTransaction,generateSigningMessageForTransaction,AccountAuthenticatorEd25519,Ed25519Signature,generateSignedTransaction,SignedTransaction,postAptosFullNode,MimeType,KeylessPublicKey,FederatedKeylessPublicKey,AbstractKeylessAccount}from'@aptos-labs/ts-sdk';import ye from'bs58';import {toBase64 as toBase64$1}from'@mysten/bcs';import {SuiHTTPTransport}from'@mysten/sui/client';import {messageWithIntent,toSerializedSignature}from'@mysten/sui/cryptography';import {Ed25519PublicKey as Ed25519PublicKey$1}from'@mysten/sui/keypairs/ed25519';import {blake2b}from'@noble/hashes/blake2b';import {createHash}from'crypto';import {encodeAccountID}from'ripple-address-codec';import {encode}from'ripple-binary-codec';import {Client}from'xrpl';import {FailoverRpcProvider,JsonRpcProvider}from'@near-js/providers';import {actionCreators}from'@near-js/transactions';import {getTransactionLastResult}from'@near-js/utils';var At=Object.defineProperty;var g=(s,t)=>{for(var e in t)At(s,e,{get:t[e],enumerable:true});};var rt={};g(rt,{CHAINS:()=>w,CONTRACT_ADDRESSES:()=>Bt,ENVS:()=>y,KDF_CHAIN_IDS:()=>v,ROOT_PUBLIC_KEYS:()=>Et});var y={TESTNET_DEV:"TESTNET_DEV",TESTNET:"TESTNET",MAINNET:"MAINNET"},w={ETHEREUM:"ETHEREUM",NEAR:"NEAR"},Et={[y.TESTNET_DEV]:"secp256k1:54hU5wcCmVUPFWLDALXMh1fFToZsVXrx9BbTbHzSfQq1Kd1rJZi52iPa4QQxo6s5TgjWqgpY8HamYuUDzG6fAaUq",[y.TESTNET]:"secp256k1:3Ww8iFjqTHufye5aRGUvrQqETegR4gVUcW8FX5xzscaN9ENhpkffojsxJwi6N1RbbHMTxYa9UyKeqK3fsMuwxjR5",[y.MAINNET]:"secp256k1:4tY4qMzusmgX5wYdG35663Y3Qar3CTbpApotwk9ZKLoF79XA4DjG8XoByaKdNHKQX9Lz5hd7iJqsWdTKyA7dKa6Z"},v={[w.ETHEREUM]:"0x1",[w.NEAR]:"0x18d"},Bt={[w.NEAR]:{[y.TESTNET_DEV]:"dev.sig-net.testnet",[y.TESTNET]:"v1.sig-net.testnet",[y.MAINNET]:"v1.sig-net.near"},[w.ETHEREUM]:{[y.TESTNET_DEV]:"0x69C6b28Fdc74618817fa380De29a653060e14009",[y.TESTNET]:"0x83458E8Bf8206131Fe5c05127007FA164c0948A2",[y.MAINNET]:"0xf8bdC0612361a1E49a8E01423d4C0cFc5dF4791A"}};var it={};g(it,{cryptography:()=>m});var m={};g(m,{compressPubKey:()=>Vt,deriveChildPublicKey:()=>Nt,najToUncompressedPubKeySEC1:()=>K,toRSV:()=>It,uint8ArrayToHex:()=>H});var It=s=>{if("big_r"in s&&typeof s.big_r=="object"&&"affine_point"in s.big_r&&"s"in s&&typeof s.s=="object"&&"scalar"in s.s)return {r:s.big_r.affine_point.substring(2),s:s.s.scalar,v:s.recovery_id+27};if("big_r"in s&&typeof s.big_r=="string"&&"s"in s&&typeof s.s=="string")return {r:s.big_r.substring(2),s:s.s,v:s.recovery_id+27};if("bigR"in s&&"x"in s.bigR&&"s"in s&&typeof s.s=="bigint")return {r:s.bigR.x.toString(16).padStart(64,"0"),s:s.s.toString(16).padStart(64,"0"),v:s.recoveryId+27};throw new Error("Invalid signature format")},Vt=s=>{let t=s.slice(2);if(t.length!==128)throw new Error("Invalid uncompressed public key length");let e=t.slice(0,64),n=t.slice(64);return (parseInt(n.slice(-1),16)%2===0?"02":"03")+e},K=s=>{let t=base58.decode(s.split(":")[1]);return `04${Buffer.from(t).toString("hex")}`};function Nt(s,t,e="",n){let r=new Kt.ec("secp256k1"),a=`sig.network v1.0.0 epsilon derivation,${n},${t},${e}`,o="";if(n===v.ETHEREUM)o=keccak256(Buffer.from(a)).slice(2);else if(n===v.NEAR)o=Ut.sha3_256(a);else throw new Error("Invalid chain ID");let u=s.substring(2,66),c=s.substring(66),d=r.curve.point(u,c),l=r.g.mul(o),E=d.add(l),B=E.getX().toString("hex").padStart(64,"0"),z=E.getY().toString("hex").padStart(64,"0");return `04${B}${z}`}var H=s=>Array.from(s).map(t=>t.toString(16).padStart(2,"0")).join("");var St={};g(St,{ChainAdapter:()=>p,aptos:()=>q,btc:()=>$,cosmos:()=>X,evm:()=>D,solana:()=>G,sui:()=>J,xrp:()=>Q});var p=class{};var D={};g(D,{EVM:()=>I,fetchEVMFeeProperties:()=>U});async function U(s,t){let e=t.gas?Promise.resolve(t.gas):s.estimateGas({account:t.from,...t}),n=t.maxFeePerGas&&t.maxPriorityFeePerGas?Promise.resolve({maxFeePerGas:t.maxFeePerGas,maxPriorityFeePerGas:t.maxPriorityFeePerGas}):s.estimateFeesPerGas(),[r,i]=await Promise.all([e,n]),a=i.maxFeePerGas??BigInt(1e10),o=i.maxPriorityFeePerGas??BigInt(1e10);return {gas:r,maxFeePerGas:a,maxPriorityFeePerGas:o}}var I=class extends p{constructor({publicClient:t,contract:e}){super(),this.contract=e,this.client=t;}async attachGasAndNonce(t){let e=await U(this.client,t),n=t.nonce??await this.client.getTransactionCount({address:t.from}),{from:r,...i}=t;return {...e,nonce:n,chainId:Number(await this.client.getChainId()),type:"eip1559",...i}}async attachGasAndNonceLegacy(t){let e=t.gasPrice??await this.client.getGasPrice(),n=t.nonce??await this.client.getTransactionCount({address:t.from}),{from:r,...i}=t;return {...i,gasPrice:BigInt(e),nonce:Number(n),value:i.value!==void 0?BigInt(i.value):void 0,gas:i.gas!==void 0?BigInt(i.gas):BigInt(21e3),chainId:await this.client.getChainId(),type:"legacy"}}transformRSVSignature(t){return {r:`0x${t.r}`,s:`0x${t.s}`,yParity:t.v-27}}assembleSignature(t){let{r:e,s:n,yParity:r}=this.transformRSVSignature(t);if(r===void 0)throw new Error("Missing yParity");return concatHex([e,n,numberToHex(r+27,{size:1})])}async deriveAddressAndPublicKey(t,e){let n=await this.contract.getDerivedPublicKey({path:e,predecessor:t});if(!n)throw new Error("Failed to get derived public key");let r=n.startsWith("04")?n.slice(2):n,i=keccak256(Buffer.from(r,"hex"));return {address:getAddress(`0x${i.slice(-40)}`),publicKey:n}}async getBalance(t){return {balance:await this.client.getBalance({address:t}),decimals:18}}serializeTransaction(t){return serializeTransaction(t)}deserializeTransaction(t){return parseTransaction(t)}async prepareTransactionForSigning(t){let e=await this.attachGasAndNonce(t),n=serializeTransaction(e),r=toBytes(keccak256(n));return {transaction:e,hashesToSign:[Array.from(r)]}}async prepareTransactionForSigningLegacy(t){let e=await this.attachGasAndNonceLegacy(t),n=serializeTransaction(e),r=toBytes(keccak256(n));return {transaction:e,hashesToSign:[Array.from(r)]}}async prepareMessageForSigning(t){return {hashToSign:Array.from(toBytes(hashMessage(t)))}}async prepareTypedDataForSigning(t){return {hashToSign:Array.from(toBytes(hashTypedData(t)))}}async prepareUserOpForSigning(t,e,n){let r=n??await this.client.getChainId(),i=e||"0x0000000071727De22E5E9d8BAf0edAc6f37da032",a=encodeAbiParameters([{type:"bytes32"},{type:"address"},{type:"uint256"}],[keccak256(encodeAbiParameters([{type:"address"},{type:"uint256"},{type:"bytes32"},{type:"bytes32"},{type:"bytes32"},{type:"uint256"},{type:"bytes32"},{type:"bytes32"}],[t.sender,hexToBigInt(t.nonce),keccak256("factory"in t&&"factoryData"in t&&t.factory&&t.factoryData?concat([t.factory,t.factoryData]):"initCode"in t?t.initCode:"0x"),keccak256(t.callData),concat([pad(t.verificationGasLimit,{size:16}),pad(t.callGasLimit,{size:16})]),hexToBigInt(t.preVerificationGas),concat([pad(t.maxPriorityFeePerGas,{size:16}),pad(t.maxFeePerGas,{size:16})]),keccak256("paymaster"in t&&t.paymaster&&isAddress(t.paymaster)?concat([t.paymaster,pad(t.paymasterVerificationGasLimit,{size:16}),pad(t.paymasterPostOpGasLimit,{size:16}),t.paymasterData]):"paymasterAndData"in t?t.paymasterAndData:"0x")])),i,BigInt(r)]),o=keccak256(a);return {userOp:t,hashToSign:Array.from(toBytes(hashMessage({raw:o})))}}prepareAuthorizationForSigning(t){let e=t.contractAddress??t.address;return {hashToSign:Array.from(toBytes(hashAuthorization({address:e,chainId:t.chainId,nonce:t.nonce})))}}finalizeTransactionSigning({transaction:t,rsvSignatures:e}){let n=this.transformRSVSignature(e[0]);return serializeTransaction(t,n)}finalizeTransactionSigningLegacy({transaction:t,rsvSignatures:e}){let n={v:BigInt(e[0].v),r:`0x${e[0].r.padStart(64,"0")}`,s:`0x${e[0].s.padStart(64,"0")}`,yParity:e[0].v-27};return serializeTransaction(t,n)}finalizeMessageSigning({rsvSignature:t}){return this.assembleSignature(t)}finalizeTypedDataSigning({rsvSignature:t}){return this.assembleSignature(t)}finalizeUserOpSigning({userOp:t,rsvSignature:e}){let{r:n,s:r,yParity:i}=this.transformRSVSignature(e);if(i===void 0)throw new Error("Missing yParity");return {...t,signature:concatHex(["0x00",n,r,numberToHex(Number(i+27),{size:1})])}}finalizeAuthorizationSigning(t){return {address:t.authorization.contractAddress??t.authorization.address,chainId:t.authorization.chainId,nonce:t.authorization.nonce,...this.transformRSVSignature(t.rsvSignature)}}async broadcastTx(t){try{return {hash:await this.client.sendRawTransaction({serializedTransaction:t})}}catch(e){throw console.error("Transaction broadcast failed:",e),new Error("Failed to broadcast transaction.")}}};var $={};g($,{BTCRpcAdapter:()=>T,BTCRpcAdapters:()=>dt,Bitcoin:()=>N,Mempool:()=>S});function O(s){switch(s.toLowerCase()){case "mainnet":return h.networks.bitcoin;case "testnet":return h.networks.testnet;case "regtest":return h.networks.regtest;default:throw new Error(`Unknown Bitcoin network: ${s}`)}}var N=class s extends p{static{this.SATOSHIS_PER_BTC=1e8;}constructor({network:t,contract:e,btcRpcAdapter:n}){super(),this.network=t,this.btcRpcAdapter=n,this.contract=e;}static toBTC(t){return t/s.SATOSHIS_PER_BTC}static toSatoshi(t){return Math.round(t*s.SATOSHIS_PER_BTC)}async fetchTransaction(t){let e=await this.btcRpcAdapter.getTransaction(t),n=new h.Transaction;return e.vout.forEach(r=>{let i=Buffer.from(r.scriptpubkey,"hex");n.addOutput(i,Number(r.value));}),n}static transformRSVSignature(t){let e=t.r.padStart(64,"0"),n=t.s.padStart(64,"0"),r=Buffer.from(e+n,"hex");if(r.length!==64)throw new Error("Invalid signature length.");return r}async createPSBT({transactionRequest:t}){let{inputs:e,outputs:n}=t.inputs&&t.outputs?t:await this.btcRpcAdapter.selectUTXOs(t.from,[{address:t.to,value:parseFloat(t.value)}]),r=new h.Psbt({network:O(this.network)});return await Promise.all(e.map(async i=>{if(!i.scriptPubKey){let o=(await this.fetchTransaction(i.txid)).outs[i.vout];i.scriptPubKey=o.script;}r.addInput({hash:i.txid,index:i.vout,witnessUtxo:{script:i.scriptPubKey,value:i.value}});})),n.forEach(i=>{"address"in i?r.addOutput({address:i.address,value:i.value}):"script"in i?r.addOutput({script:i.script,value:i.value}):t.from!==void 0&&r.addOutput({value:Number(i.value),address:t.from});}),r}async getBalance(t){return {balance:BigInt(await this.btcRpcAdapter.getBalance(t)),decimals:8}}async deriveAddressAndPublicKey(t,e){let n=await this.contract.getDerivedPublicKey({path:e,predecessor:t});if(!n)throw new Error("Failed to get derived public key");let r=m.compressPubKey(n),i=Buffer.from(r,"hex"),a=O(this.network),o=h.payments.p2wpkh({pubkey:i,network:a}),{address:u}=o;if(!u)throw new Error("Failed to generate Bitcoin address");return {address:u,publicKey:r}}serializeTransaction(t){return JSON.stringify({psbt:t.psbt.toHex(),publicKey:t.publicKey})}deserializeTransaction(t){let e=JSON.parse(t);return {psbt:h.Psbt.fromHex(e.psbt),publicKey:e.publicKey}}async prepareTransactionForSigning(t){let e=Buffer.from(t.publicKey,"hex"),n=await this.createPSBT({transactionRequest:t}),r=n.toHex(),i=[],a=o=>({publicKey:e,sign:u=>(i[o]=Array.from(u),Buffer.alloc(64))});for(let o=0;o<n.inputCount;o++)n.signInput(o,a(o));return {transaction:{psbt:h.Psbt.fromHex(r),publicKey:t.publicKey},hashesToSign:i}}finalizeTransactionSigning({transaction:{psbt:t,publicKey:e},rsvSignatures:n}){let r=Buffer.from(e,"hex"),i=a=>({publicKey:r,sign:()=>{let o=n[a];return s.transformRSVSignature(o)}});for(let a=0;a<t.inputCount;a++)t.signInput(a,i(a));return t.finalizeAllInputs(),t.extractTransaction().toHex()}async broadcastTx(t){return {hash:await this.btcRpcAdapter.broadcastTransaction(t)}}};var T=class{};var S=class extends T{constructor(t){super(),this.providerUrl=t;}async fetchFeeRate(t=6){let n=await(await fetch(`${this.providerUrl}/v1/fees/recommended`)).json();return t<=1?n.fastestFee:t<=3?n.halfHourFee:t<=6?n.hourFee:n.economyFee}async fetchUTXOs(t){try{return await(await fetch(`${this.providerUrl}/address/${t}/utxo`)).json()}catch(e){return console.error("Failed to fetch UTXOs:",e),[]}}async selectUTXOs(t,e,n=6){let r=await this.fetchUTXOs(t),i=await this.fetchFeeRate(n),a=Ht(r,e,Math.ceil(i+1));if(!a.inputs||!a.outputs)throw new Error("Invalid transaction: coinselect failed to find a suitable set of inputs and outputs. This could be due to insufficient funds, or no inputs being available that meet the criteria.");return {inputs:a.inputs,outputs:a.outputs}}async broadcastTransaction(t){let e=await fetch(`${this.providerUrl}/tx`,{method:"POST",body:t});if(e.ok)return await e.text();throw new Error(`Failed to broadcast transaction: ${await e.text()}`)}async getBalance(t){let n=await(await fetch(`${this.providerUrl}/address/${t}`)).json();return n.chain_stats.funded_txo_sum-n.chain_stats.spent_txo_sum}async getTransaction(t){return await(await fetch(`${this.providerUrl}/tx/${t}`)).json()}};var dt={Mempool:S};var X={};g(X,{Cosmos:()=>k});var pt=async s=>{let t=chains.find(l=>l.chain_id===s);if(!t)throw new Error(`Chain info not found for chainId: ${s}`);let{bech32_prefix:e,chain_id:n}=t,r=t.staking?.staking_tokens?.[0]?.denom,i=t.apis?.rpc?.[0]?.address,a=t.apis?.rest?.[0]?.address,o=t.fees?.fee_tokens?.[0]?.average_gas_price;if(!e||!r||!i||!a||!n||o===void 0)throw new Error(`Missing required chain information for ${t.chain_name}`);let c=assets.find(l=>l.chain_name===t.chain_name)?.assets.find(l=>l.base===r),d=c?.denom_units.find(l=>l.denom===c.display)?.exponent;if(d===void 0)throw new Error(`Could not find decimals for ${r} on chain ${t.chain_name}`);return {prefix:e,denom:r,rpcUrl:i,restUrl:a,expectedChainId:n,gasPrice:o,decimals:d}};var k=class extends p{constructor({chainId:t,contract:e,endpoints:n}){super(),this.contract=e,this.registry=new Registry,this.chainId=t,this.endpoints=n;}transformRSVSignature(t){return new Uint8Array([...fromHex(t.r),...fromHex(t.s)])}async getChainInfo(){return {...await pt(this.chainId),...this.endpoints}}async getBalance(t){try{let{restUrl:e,denom:n,decimals:r}=await this.getChainInfo(),i=await fetch(`${e}/cosmos/bank/v1beta1/balances/${t}`);if(!i.ok)throw new Error(`HTTP error! status: ${i.status}`);let u=(await i.json()).balances.find(c=>c.denom===n)?.amount??"0";return {balance:BigInt(u),decimals:r}}catch(e){throw console.error("Failed to fetch Cosmos balance:",e),new Error("Failed to fetch Cosmos balance")}}async deriveAddressAndPublicKey(t,e){let{prefix:n}=await this.getChainInfo(),r=await this.contract.getDerivedPublicKey({path:e,predecessor:t});if(!r)throw new Error("Failed to get derived public key");let i=m.compressPubKey(r),a=sha256(fromHex(i)),o=ripemd160(a);return {address:bech32.encode(n,bech32.toWords(o)),publicKey:i}}serializeTransaction(t){let e=TxRaw.encode(t).finish();return toBase64(e)}deserializeTransaction(t){return TxRaw.decode(fromBase64(t))}async prepareTransactionForSigning(t){let{denom:e,rpcUrl:n,gasPrice:r}=await this.getChainInfo(),i=fromHex(t.publicKey),a=t.gas||2e5,o=calculateFee(a,GasPrice.fromString(`${r}${e}`)),c=await(await StargateClient.connect(n)).getAccount(t.address);if(!c)throw new Error(`Account ${t.address} does not exist on chain`);let{accountNumber:d,sequence:l}=c,E={typeUrl:"/cosmos.tx.v1beta1.TxBody",value:{messages:t.messages,memo:t.memo||""}},B=this.registry.encode(E),z=encodePubkey(encodeSecp256k1Pubkey(i)),nt=makeAuthInfoBytes([{pubkey:z,sequence:l}],o.amount,Number(o.gas),void 0,void 0,SignMode.SIGN_MODE_DIRECT),xt=makeSignDoc(B,nt,this.chainId,d),wt=makeSignBytes(xt),Ct=Array.from(sha256(wt));return {transaction:TxRaw.fromPartial({bodyBytes:B,authInfoBytes:nt,signatures:[]}),hashesToSign:[Ct]}}finalizeTransactionSigning({transaction:t,rsvSignatures:e}){t.signatures=e.map(r=>this.transformRSVSignature(r));let n=TxRaw.encode(t).finish();return Buffer.from(n).toString("hex")}async broadcastTx(t){try{let{rpcUrl:e}=await this.getChainInfo(),n=await StargateClient.connect(e),r=fromHex(t),i=await n.broadcastTx(r);if(i.code!==0)throw new Error(`Broadcast error: ${i.rawLog}`);return i.transactionHash}catch(e){throw console.error("Transaction broadcast failed:",e),new Error("Failed to broadcast transaction.")}}};var G={};g(G,{Solana:()=>L});var ne=s=>typeof s=="bigint"?s:BigInt(s.toString()),L=class extends p{constructor(t){super(),this.connection=t.solanaConnection,this.contract=t.contract;}async getBalance(t){let e=new PublicKey(t),n=await this.connection.getBalance(e);return {balance:BigInt(n),decimals:9}}async deriveAddressAndPublicKey(t,e){let r=(await this.contract.getDerivedPublicKey({path:e,predecessor:t,IsEd25519:true})).replace("ed25519:",""),i=new PublicKey(r);return {address:i.toBase58(),publicKey:i.toString()}}serializeTransaction(t){return Buffer.from(t.transaction.serialize({requireAllSignatures:false})).toString("base64")}deserializeTransaction(t){let e=Buffer.from(t,"base64"),n=Transaction.from(e);return {transaction:n,feePayer:n.feePayer||new PublicKey("11111111111111111111111111111111"),recentBlockhash:n.recentBlockhash||""}}async prepareTransactionForSigning(t){let e=new Transaction,n=ne(t.amount);n>0n&&e.add(SystemProgram.transfer({fromPubkey:new PublicKey(t.from),toPubkey:new PublicKey(t.to),lamports:Number(n)})),t.instructions&&e.add(...t.instructions);let{blockhash:r}=await this.connection.getLatestBlockhash();e.recentBlockhash=r,e.feePayer=t.feePayer||new PublicKey(t.from);let i=e.compileMessage().serialize();return {transaction:{transaction:e,feePayer:e.feePayer,recentBlockhash:r},hashesToSign:[Array.from(i)]}}finalizeTransactionSigning({transaction:t,rsvSignatures:e,senderAddress:n}){let r=Buffer.from(e.signature);return t.addSignature(new PublicKey(n),r),t.serialize().toString("base64")}async broadcastTx(t){let e=this.deserializeTransaction(t);return {hash:await this.connection.sendRawTransaction(e.transaction.serialize())}}};var q={};g(q,{Aptos:()=>M});var M=class extends p{constructor({contract:t,client:e}){super(),this.contract=t,this.client=e;}async getBalance(t){let e=await this.client.account.getAccountAPTAmount({accountAddress:t});return {balance:BigInt(e),decimals:8}}async deriveAddressAndPublicKey(t,e){let r=(await this.contract.getDerivedPublicKey({path:e,predecessor:t,IsEd25519:true})).replace("ed25519:",""),i=ye.decode(r),a="0x"+Buffer.from(i).toString("hex");return {address:new Ed25519PublicKey(i).authKey().derivedAddress().toString(),publicKey:a}}serializeTransaction(t){return t.bcsToHex().toString()}deserializeTransaction(t){let e=t.startsWith("0x"),n=Buffer.from(e?t.slice(2):t,"hex");try{let i=new Deserializer(n);return MultiAgentTransaction.deserialize(i)}catch{}let r=new Deserializer(n);return SimpleTransaction.deserialize(r)}async prepareTransactionForSigning(t){return {transaction:t,hashesToSign:[generateSigningMessageForTransaction(t)]}}rsvSignatureToSenderAuthenticator(t){let e=Buffer.from(t.rsvSignatures.signature),n=t.publicKey.startsWith("0x"),r=Buffer.from(n?t.publicKey.slice(2):t.publicKey,"hex"),i=new Ed25519PublicKey(r);return new AccountAuthenticatorEd25519(i,new Ed25519Signature(e.toString("hex")))}finalizeTransactionSigning(t){let e=this.rsvSignatureToSenderAuthenticator({rsvSignatures:t.rsvSignatures,publicKey:t.publicKey}),n=generateSignedTransaction({transaction:t.transaction,senderAuthenticator:e,additionalSignersAuthenticators:t.additionalSignersAuthenticators,feePayerAuthenticator:t.feePayerAuthenticator});return "0x"+Buffer.from(n).toString("hex")}deserializeSignedTransaction(t){let e=t.startsWith("0x"),n=Buffer.from(e?t.slice(2):t,"hex"),r=new Deserializer(n);return SignedTransaction.deserialize(r)}async broadcastTx(t){let e=this.deserializeSignedTransaction(t);try{let{data:n}=await postAptosFullNode({aptosConfig:this.client.config,body:e.bcsToBytes(),path:"transactions",originMethod:"submitTransaction",contentType:MimeType.BCS_SIGNED_TRANSACTION});return {hash:n.hash}}catch(n){throw e.authenticator.isSingleSender()&&e.authenticator.sender.isSingleKey()&&(e.authenticator.sender.public_key.publicKey instanceof KeylessPublicKey||e.authenticator.sender.public_key.publicKey instanceof FederatedKeylessPublicKey)&&await AbstractKeylessAccount.fetchJWK({aptosConfig:this.client.config,publicKey:e.authenticator.sender.public_key.publicKey,kid:e.authenticator.sender.signature.signature.getJwkKid()}),n}}};var J={};g(J,{SUI:()=>W});var W=class extends p{constructor({contract:t,client:e,rpcUrl:n}){super(),this.contract=t,this.client=e,this.transport=new SuiHTTPTransport({url:n});}async getBalance(t){let e=await this.client.getBalance({owner:t});return {balance:BigInt(e.totalBalance),decimals:9}}async deriveAddressAndPublicKey(t,e){let r=(await this.contract.getDerivedPublicKey({path:e,predecessor:t,IsEd25519:true})).replace("ed25519:",""),i=ye.decode(r),a=new Ed25519PublicKey$1(i);return {publicKey:a.toSuiPublicKey(),address:a.toSuiAddress()}}serializeTransaction(t){return Buffer.from(t).toString("hex")}deserializeTransaction(t){let e=Buffer.from(t,"hex");return new Uint8Array(e)}async prepareTransactionForSigning(t){let e=await t.build({client:this.client}),r=messageWithIntent("TransactionData",e);return {hashesToSign:[blake2b(r,{dkLen:32})],transaction:e}}rsvSignatureToSuiSignature(t){let n=Buffer.from(t.publicKey,"base64").subarray(1);return toSerializedSignature({signature:Buffer.from(t.rsvSignatures.signature),signatureScheme:"ED25519",publicKey:new Ed25519PublicKey$1(n)})}finalizeTransactionSigning(t){let e=this.rsvSignatureToSuiSignature(t);return JSON.stringify([typeof t.transaction=="string"?t.transaction:toBase64$1(t.transaction),Array.isArray(e)?e:[e]])}async broadcastTx(t){return {hash:(await this.transport.request({method:"sui_executeTransactionBlock",params:JSON.parse(t)})).digest}}};var Q={};g(Q,{XRP:()=>F});var F=class extends p{constructor({rpcUrl:t,contract:e,client:n}){super(),this.rpcUrl=t,this.contract=e,this.client=n||new Client(this.rpcUrl);}async getBalance(t){try{await this.client.connect();let e=await this.client.request({command:"account_info",account:t,ledger_index:"validated"});return {balance:BigInt(String(e?.result?.account_data?.Balance))||0n,decimals:6}}catch(e){if(e?.data?.error==="actNotFound"||e?.message?.includes("Account not found")||e?.data?.error_message?.includes("Account not found"))return {balance:0n,decimals:6};throw console.error("Failed to fetch XRP balance:",e),new Error("Failed to fetch XRP balance")}finally{try{await this.client.disconnect();}catch(e){console.warn("Error disconnecting XRP client:",e);}}}async deriveAddressAndPublicKey(t,e){let n=await this.contract.getDerivedPublicKey({path:e,predecessor:t});if(!n)throw new Error("Failed to get derived secp256k1 public key");let r=m.compressPubKey(n);return {address:this.deriveXRPAddress(r),publicKey:r}}deriveXRPAddress(t){let e=Buffer.from(t,"hex"),n=createHash("sha256").update(e).digest(),r=createHash("ripemd160").update(n).digest();return encodeAccountID(r)}serializeTransaction(t){return JSON.stringify(t)}deserializeTransaction(t){return JSON.parse(t)}async prepareTransactionForSigning(t){try{await this.client.connect();let e=t.publicKey,n=await this.client.autofill({TransactionType:"Payment",Account:t.from,Destination:t.to,Amount:t.amount,SigningPubKey:e.toUpperCase()}),r={transaction:n,signingPubKey:e},i=encode(n),a=new Uint8Array([83,84,88,0]),o=new Uint8Array(Buffer.from(i,"hex")),u=new Uint8Array(a.length+o.length);u.set(a,0),u.set(o,a.length);let c=createHash("sha512").update(u).digest(),d=new Uint8Array(c.subarray(0,32));return {transaction:r,hashesToSign:[d]}}catch(e){throw console.error("Failed to prepare XRP transaction for signing:",e),new Error("Failed to prepare XRP transaction for signing")}}finalizeTransactionSigning({transaction:t,rsvSignatures:e}){if(e.length===0)throw new Error("Invalid signatures provided");let n=e[0],r=this.generateTxnSignature(n.r,n.s,n.v),i={...t.transaction,TxnSignature:r,SigningPubKey:t.signingPubKey.toUpperCase()};return JSON.stringify(i)}generateTxnSignature(t,e,n){let r=Buffer.from(t,"hex"),i=Buffer.from(e,"hex"),a=r;r[0]>127&&(a=Buffer.concat([Buffer.from([0]),r]));let o=i;i[0]>127&&(o=Buffer.concat([Buffer.from([0]),i]));let u=2+a.length+2+o.length,c=Buffer.alloc(2+u),d=0;return c.writeUInt8(48,d++),c.writeUInt8(u,d++),c.writeUInt8(2,d++),c.writeUInt8(a.length,d++),a.copy(c,d),d+=a.length,c.writeUInt8(2,d++),c.writeUInt8(o.length,d++),o.copy(c,d),c.toString("hex").toUpperCase()}async broadcastTx(t){try{await this.client.connect();let e=JSON.parse(t),n=encode(e),r=await this.client.submit(n);if(await this.client.disconnect(),r.result.engine_result==="tesSUCCESS"||r.result.engine_result==="terQUEUED"){let i=r.result.tx_json?.hash;if(!i)throw new Error("Transaction submitted but no hash received");return {hash:i}}else throw new Error(`Transaction failed: ${r.result.engine_result} - ${r.result.engine_result==="terQUEUED"?"Transaction is queued":r.result.engine_result}`)}catch(e){throw console.error("Failed to broadcast XRP transaction:",e),new Error("Failed to broadcast XRP transaction")}}};var Pt={};g(Pt,{ChainSignatureContract:()=>et,utils:()=>ve});var tt={};g(tt,{responseToMpcSignature:()=>Z});var Z=({signature:s})=>{if("scheme"in s&&s.scheme==="Ed25519"&&"signature"in s)return s;if(s)return m.toRSV(s)};var bt="300000000000000";var et=class{constructor({contractId:t,networkId:e,fallbackRpcUrls:n}){this.contractId=t,this.networkId=e;let r=n&&n.length>0?n:[`https://rpc.${this.networkId}.near.org`];this.provider=new FailoverRpcProvider(r.map(i=>new JsonRpcProvider({url:i})));}getCurrentSignatureDeposit(){return 1}async sign({payloads:t,path:e,keyType:n,signerAccount:r}){let i=t.map(c=>({signerId:r.accountId,receiverId:this.contractId,actions:[actionCreators.functionCall("sign",{request:{payload_v2:{[n]:H(c)},path:e,domain_id:n==="Eddsa"?1:0}},BigInt(bt),BigInt(1))]}));return (await r.signAndSendTransactions({transactions:i})).map(c=>getTransactionLastResult(c)).map(c=>Z({signature:c}))}async getPublicKey(){let t=await this.provider.callFunction(this.contractId,"public_key",{});return K(t)}async getDerivedPublicKey(t){let e=await this.provider.callFunction(this.contractId,"derived_public_key",{path:t.path,predecessor:t.predecessor,domain_id:t.IsEd25519?1:0});return K(e)}};var ve={transaction:tt};
export{St as chainAdapters,rt as constants,Pt as contracts,it as utils};//# sourceMappingURL=index.browser.js.map
//# sourceMappingURL=index.browser.js.map