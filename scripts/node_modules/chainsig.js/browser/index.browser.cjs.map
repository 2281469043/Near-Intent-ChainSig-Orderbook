{"version":3,"sources":["../../src/constants.ts","../../src/utils/index.ts","../../src/utils/cryptography.ts","../../src/chain-adapters/index.ts","../../src/chain-adapters/ChainAdapter.ts","../../src/chain-adapters/EVM/index.ts","../../src/chain-adapters/EVM/utils.ts","../../src/chain-adapters/EVM/EVM.ts","../../src/chain-adapters/Bitcoin/index.ts","../../src/chain-adapters/Bitcoin/Bitcoin.ts","../../src/chain-adapters/Bitcoin/utils.ts","../../src/chain-adapters/Bitcoin/BTCRpcAdapter/BTCRpcAdapter.ts","../../src/chain-adapters/Bitcoin/BTCRpcAdapter/Mempool/Mempool.ts","../../src/chain-adapters/Bitcoin/BTCRpcAdapter/index.ts","../../src/chain-adapters/Cosmos/index.ts","../../src/chain-adapters/Cosmos/utils.ts","../../src/chain-adapters/Cosmos/Cosmos.ts","../../src/chain-adapters/Solana/index.ts","../../src/chain-adapters/Solana/Solana.ts","../../src/chain-adapters/Aptos/index.ts","../../src/chain-adapters/Aptos/Aptos.ts","../../src/chain-adapters/SUI/index.ts","../../src/chain-adapters/SUI/SUI.ts","../../src/chain-adapters/XRP/index.ts","../../src/chain-adapters/XRP/XRP.ts","../../src/contracts/index.ts","../../src/contracts/transaction.ts","../../src/contracts/constants.ts","../../src/contracts/ChainSignatureContract.ts"],"names":["constants_exports","__export","CHAINS","CONTRACT_ADDRESSES","ENVS","KDF_CHAIN_IDS","ROOT_PUBLIC_KEYS","utils_exports","cryptography_exports","compressPubKey","deriveChildPublicKey","najToUncompressedPubKeySEC1","toRSV","uint8ArrayToHex","signature","uncompressedPubKeySEC1","slicedPubKey","x","y","najPublicKey","decodedKey","base58","rootUncompressedPubKeySEC1","predecessorId","path","chainId","ec","elliptic","derivationPath","scalarHex","keccak256","sha","oldPublicKeyPoint","scalarTimesG","newPublicKeyPoint","newX","newY","uint8Array","byte","chain_adapters_exports","ChainAdapter","Aptos_exports","Bitcoin_exports","Cosmos_exports","EVM_exports","Solana_exports","SUI_exports","XRP_exports","EVM","fetchEVMFeeProperties","client","transaction","gasPromise","feeDataPromise","gas","feeData","maxFeePerGas","maxPriorityFeePerGas","publicClient","contract","fees","nonce","from","rest","gasPrice","r","s","yParity","concatHex","numberToHex","predecessor","uncompressedPubKey","publicKeyNoPrefix","hash","getAddress","address","serializeTransaction","serialized","parseTransaction","transactionRequest","serializedTx","txHash","toBytes","message","hashMessage","typedDataRequest","hashTypedData","userOp","entryPointAddress","chainIdArgs","entryPoint","encoded","encodeAbiParameters","hexToBigInt","concat","pad","isAddress","userOpHash","params","hashAuthorization","rsvSignatures","rsvSignature","txSerialized","error","BTCRpcAdapter","BTCRpcAdapters","Bitcoin","Mempool","parseBTCNetwork","network","V","_Bitcoin","btcRpcAdapter","satoshis","btc","transactionId","data","tx","h","vout","scriptPubKey","rawSignature","inputs","outputs","psbt","input","prevOut","out","derivedKey","publicKeyBuffer","payment","transactionJSON","psbtHex","hashesToSign","mockKeyPair","index","publicKey","keyPair","mpcSignature","providerUrl","confirmationTarget","targets","utxos","feeRate","ret","coinselect","transactionHex","response","txid","Cosmos","fetchChainInfo","chainInfo","chains","chain","prefix","expectedChainId","denom","rpcUrl","restUrl","asset","assets","decimals","unit","endpoints","Registry","fromHex","amount","b","pubKeySha256","sha256","ripemd160Hash","ripemd160","bech32","TxRaw","toBase64","fromBase64","publicKeyBytes","gasLimit","fee","calculateFee","GasPrice","accountOnChain","StargateClient","accountNumber","sequence","txBodyEncodeObject","txBodyBytes","pubkey","encodePubkey","encodeSecp256k1Pubkey","authInfoBytes","makeAuthInfoBytes","SignMode","signDoc","makeSignDoc","signBytes","makeSignBytes","payload","sig","txBytes","broadcastResponse","Solana","toBigInt","value","args","PublicKey","balance","base58Key","buffer","Transaction","request","SystemProgram","blockhash","messageBytes","senderAddress","signatureBuffer","Aptos","bytes","bs58","Ed25519PublicKey","isPrefixWith0x","deserializer","Deserializer","MultiAgentTransaction","SimpleTransaction","generateSigningMessageForTransaction","isPublicKeyPrefixWith0x","AccountAuthenticatorEd25519","Ed25519Signature","senderAuthenticator","signedTx","generateSignedTransaction","serializedSignedTransaction","SignedTransaction","signedTransaction","postAptosFullNode","MimeType","e","KeylessPublicKey","FederatedKeylessPublicKey","AbstractKeylessAccount","SUI","SuiHTTPTransport","pubKeyInSui","intentMessage","messageWithIntent","blake2b","rawPublicKeyBuffer","toSerializedSignature","XRP","Client","disconnectError","compressedPubKey","publicKeyHex","sha256Hash","createHash","encodeAccountID","signingPubKey","prepared","unsignedTx","encodedTx","encodeTx","signingPrefix","encodedBytes","signingData","signingHash","derSignature","v","rBuf","sBuf","rVal","sVal","totalLength","offset","txBlob","contracts_exports","ChainSignatureContract","utils","transaction_exports","responseToMpcSignature","NEAR_MAX_GAS","contractId","networkId","fallbackRpcUrls","rpcProviderUrls","FailoverRpcProvider","url","JsonRpcProvider","payloads","keyType","signerAccount","transactions","actionCreators","getTransactionLastResult","najPubKey"],"mappings":"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","file":"index.browser.cjs","sourcesContent":["import { type NajPublicKey } from '@types'\n\nexport const ENVS = {\n  TESTNET_DEV: 'TESTNET_DEV',\n  TESTNET: 'TESTNET',\n  MAINNET: 'MAINNET',\n} as const\n\nexport const CHAINS = {\n  ETHEREUM: 'ETHEREUM',\n  NEAR: 'NEAR',\n} as const\n\n/**\n * Root public keys for the Sig Network Smart Contracts across different environments.\n *\n * These keys should never change.\n */\nexport const ROOT_PUBLIC_KEYS: Record<keyof typeof ENVS, NajPublicKey> = {\n  [ENVS.TESTNET_DEV]:\n    'secp256k1:54hU5wcCmVUPFWLDALXMh1fFToZsVXrx9BbTbHzSfQq1Kd1rJZi52iPa4QQxo6s5TgjWqgpY8HamYuUDzG6fAaUq',\n  [ENVS.TESTNET]:\n    'secp256k1:3Ww8iFjqTHufye5aRGUvrQqETegR4gVUcW8FX5xzscaN9ENhpkffojsxJwi6N1RbbHMTxYa9UyKeqK3fsMuwxjR5',\n  [ENVS.MAINNET]:\n    'secp256k1:4tY4qMzusmgX5wYdG35663Y3Qar3CTbpApotwk9ZKLoF79XA4DjG8XoByaKdNHKQX9Lz5hd7iJqsWdTKyA7dKa6Z',\n}\n\n/**\n * Chain IDs used in the key derivation function (KDF) for deriving child public keys to\n * distinguish between different chains.\n *\n * @see {@link utils.cryptography.deriveChildPublicKey} for usage details\n */\nexport const KDF_CHAIN_IDS = {\n  [CHAINS.ETHEREUM]: '0x1',\n  [CHAINS.NEAR]: '0x18d',\n} as const\n\n/**\n * Contract addresses for different chains and environments.\n *\n * - Testnet Dev: Used for internal development, very unstable\n * - Testnet: Used for external development, stable\n * - Mainnet: Production contract address\n *\n * @see ChainSignatureContract documentation for implementation details\n */\nexport const CONTRACT_ADDRESSES: Record<\n  keyof typeof CHAINS,\n  Record<keyof typeof ENVS, string>\n> = {\n  [CHAINS.NEAR]: {\n    [ENVS.TESTNET_DEV]: 'dev.sig-net.testnet',\n    [ENVS.TESTNET]: 'v1.sig-net.testnet',\n    [ENVS.MAINNET]: 'v1.sig-net.near',\n  },\n  [CHAINS.ETHEREUM]: {\n    [ENVS.TESTNET_DEV]: '0x69C6b28Fdc74618817fa380De29a653060e14009',\n    [ENVS.TESTNET]: '0x83458E8Bf8206131Fe5c05127007FA164c0948A2',\n    [ENVS.MAINNET]: '0xf8bdC0612361a1E49a8E01423d4C0cFc5dF4791A',\n  },\n}\n","export * as cryptography from './cryptography'\n","import { base58 } from '@scure/base'\nimport elliptic from 'elliptic'\nimport sha from 'js-sha3'\nimport { keccak256 } from 'viem'\n\nimport { KDF_CHAIN_IDS } from '@constants'\nimport {\n  type NajPublicKey,\n  type MPCSignature,\n  type RSVSignature,\n  type UncompressedPubKeySEC1,\n} from '@types'\n\nexport const toRSV = (signature: MPCSignature): RSVSignature => {\n  // Handle NearNearMpcSignature\n  if (\n    'big_r' in signature &&\n    typeof signature.big_r === 'object' &&\n    'affine_point' in signature.big_r &&\n    's' in signature &&\n    typeof signature.s === 'object' &&\n    'scalar' in signature.s\n  ) {\n    return {\n      r: signature.big_r.affine_point.substring(2),\n      s: signature.s.scalar,\n      v: signature.recovery_id + 27,\n    }\n  }\n  // Handle ChainSigNearMpcSignature\n  else if (\n    'big_r' in signature &&\n    typeof signature.big_r === 'string' &&\n    's' in signature &&\n    typeof signature.s === 'string'\n  ) {\n    return {\n      r: signature.big_r.substring(2),\n      s: signature.s,\n      v: signature.recovery_id + 27,\n    }\n  }\n  // Handle ChainSigEvmMpcSignature\n  else if (\n    'bigR' in signature &&\n    'x' in signature.bigR &&\n    's' in signature &&\n    typeof signature.s === 'bigint'\n  ) {\n    return {\n      r: signature.bigR.x.toString(16).padStart(64, '0'),\n      s: signature.s.toString(16).padStart(64, '0'),\n      v: signature.recoveryId + 27,\n    }\n  }\n\n  throw new Error('Invalid signature format')\n}\n\n/**\n * Compresses an uncompressed public key to its compressed format following SEC1 standards.\n * In SEC1, a compressed public key consists of a prefix (02 or 03) followed by the x-coordinate.\n * The prefix indicates whether the y-coordinate is even (02) or odd (03).\n *\n * @param uncompressedPubKeySEC1 - The uncompressed public key in hex format, with or without '04' prefix\n * @returns The compressed public key in hex format\n * @throws Error if the uncompressed public key length is invalid\n */\nexport const compressPubKey = (\n  uncompressedPubKeySEC1: UncompressedPubKeySEC1\n): string => {\n  const slicedPubKey = uncompressedPubKeySEC1.slice(2)\n\n  if (slicedPubKey.length !== 128) {\n    throw new Error('Invalid uncompressed public key length')\n  }\n\n  const x = slicedPubKey.slice(0, 64)\n  const y = slicedPubKey.slice(64)\n\n  const isEven = parseInt(y.slice(-1), 16) % 2 === 0\n  const prefix = isEven ? '02' : '03'\n\n  return prefix + x\n}\n\n/**\n * Converts a NAJ public key to an uncompressed SEC1 public key.\n *\n * @param najPublicKey - The NAJ public key to convert (e.g. secp256k1:3Ww8iFjqTHufye5aRGUvrQqETegR4gVUcW8FX5xzscaN9ENhpkffojsxJwi6N1RbbHMTxYa9UyKeqK3fsMuwxjR5)\n * @returns The uncompressed SEC1 public key (e.g. 04 || x || y)\n */\nexport const najToUncompressedPubKeySEC1 = (\n  najPublicKey: NajPublicKey\n): UncompressedPubKeySEC1 => {\n  const decodedKey = base58.decode(najPublicKey.split(':')[1])\n  return `04${Buffer.from(decodedKey).toString('hex')}`\n}\n\n/**\n * Derives a child public key from a parent public key using the sig.network v1.0.0 epsilon derivation scheme.\n * The parent public keys are defined in @constants.ts\n *\n * @param rootUncompressedPubKeySEC1 - The parent public key in uncompressed SEC1 format (e.g. 04 || x || y)\n * @param predecessorId - The predecessor ID is the address of the account calling the signer contract (e.g EOA or Contract Address)\n * @param path - Optional derivation path suffix (defaults to empty string)\n * @param chainId - The chain ID for key derivation\n * @returns The derived child public key in uncompressed SEC1 format (04 || x || y)\n */\nexport function deriveChildPublicKey(\n  rootUncompressedPubKeySEC1: UncompressedPubKeySEC1,\n  predecessorId: string,\n  path: string = '',\n  chainId: string\n): UncompressedPubKeySEC1 {\n  // eslint-disable-next-line new-cap\n  const ec = new elliptic.ec('secp256k1')\n\n  const EPSILON_DERIVATION_PREFIX = 'sig.network v1.0.0 epsilon derivation'\n  const derivationPath = `${EPSILON_DERIVATION_PREFIX},${chainId},${predecessorId},${path}`\n\n  let scalarHex = ''\n\n  if (chainId === KDF_CHAIN_IDS.ETHEREUM) {\n    scalarHex = keccak256(Buffer.from(derivationPath)).slice(2)\n  } else if (chainId === KDF_CHAIN_IDS.NEAR) {\n    scalarHex = sha.sha3_256(derivationPath)\n  } else {\n    throw new Error('Invalid chain ID')\n  }\n\n  const x = rootUncompressedPubKeySEC1.substring(2, 66)\n  const y = rootUncompressedPubKeySEC1.substring(66)\n\n  const oldPublicKeyPoint = ec.curve.point(x, y)\n  const scalarTimesG = ec.g.mul(scalarHex)\n  const newPublicKeyPoint = oldPublicKeyPoint.add(scalarTimesG)\n\n  const newX = newPublicKeyPoint.getX().toString('hex').padStart(64, '0')\n  const newY = newPublicKeyPoint.getY().toString('hex').padStart(64, '0')\n\n  return `04${newX}${newY}`\n}\n\n/**\n * Converts a Uint8Array to a hexadecimal string.\n *\n * @param uint8Array - The Uint8Array to convert.\n * @returns The hexadecimal string representation of the Uint8Array.\n */\nexport const uint8ArrayToHex = (\n  uint8Array: number[] | Uint8Array<ArrayBufferLike>\n): string => {\n  return Array.from(uint8Array)\n    .map((byte) => byte.toString(16).padStart(2, '0'))\n    .join('')\n}\n","export { ChainAdapter } from './ChainAdapter'\n\nexport * as evm from './EVM'\nexport * as btc from './Bitcoin'\nexport * as cosmos from './Cosmos'\nexport * as solana from './Solana'\nexport * as aptos from './Aptos'\nexport * as sui from './SUI'\nexport * as xrp from './XRP'\n","import { type Transaction } from '@solana/web3.js'\n\nimport type { HashToSign, RSVSignature, Signature } from '@types'\n\nexport abstract class ChainAdapter<TransactionRequest, UnsignedTransaction> {\n  /**\n   * Gets the native token balance and decimals for a given address\n   *\n   * @param address - The address to check\n   * @returns Promise resolving to an object containing:\n   *          - balance: The balance as a bigint, in the chain's base units\n   *          - decimals: The number of decimals used to format the balance\n   */\n  abstract getBalance(address: string): Promise<{\n    balance: bigint\n    decimals: number\n  }>\n\n  /**\n   * Uses Sig Network Key Derivation Function to derive the address and public key. from a signer ID and string path.\n   *\n   * @param predecessor - The id/address of the account requesting signature\n   * @param path - The string path used to derive the key\n   * @returns Promise resolving to the derived address and public key\n   */\n  abstract deriveAddressAndPublicKey(\n    predecessor: string,\n    path: string\n  ): Promise<{\n    address: string\n    publicKey: string\n  }>\n\n  /**\n   * Serializes an unsigned transaction to a string format.\n   * This is useful for storing or transmitting the transaction.\n   *\n   * @param transaction - The unsigned transaction to serialize\n   * @returns The serialized transaction string\n   */\n  abstract serializeTransaction(transaction: UnsignedTransaction): string\n\n  /**\n   * Deserializes a transaction string back into an unsigned transaction object.\n   * This reverses the serialization done by serializeTransaction().\n   *\n   * @param serialized - The serialized transaction string\n   * @returns The deserialized unsigned transaction\n   */\n  abstract deserializeTransaction(serialized: string): UnsignedTransaction\n\n  /**\n   * Prepares a transaction for Sig Network MPC signing by creating the necessary payloads.\n   * This method handles chain-specific transaction preparation including:\n   * - Fee calculation\n   * - Nonce/sequence management\n   * - UTXO selection (for UTXO-based chains)\n   * - Transaction encoding\n   *\n   * @param transactionRequest - The transaction request containing parameters like recipient, amount, etc.\n   * @returns Promise resolving to an object containing:\n   *          - transaction: The unsigned transaction\n   *          - hashesToSign: Array of payloads to be signed by MPC. The order of these payloads must match\n   *                         the order of signatures provided to finalizeTransactionSigning()\n   */\n  abstract prepareTransactionForSigning(\n    transactionRequest: TransactionRequest\n  ): Promise<{\n    transaction: UnsignedTransaction\n    hashesToSign: HashToSign[]\n  }>\n\n  /**\n   * Adds Sig Network MPC-generated signatures to an unsigned transaction.\n   *\n   * @param params - Parameters for adding signatures\n   * @param params.transaction - The unsigned transaction to add signatures to\n   * @param params.rsvSignatures - Array of RSV signatures generated through MPC. Must be in the same order\n   *                              as the payloads returned by prepareTransactionForSigning()\n   * @returns The serialized signed transaction ready for broadcast\n   */\n  abstract finalizeTransactionSigning(params: {\n    transaction: UnsignedTransaction | Transaction\n    rsvSignatures: RSVSignature[] | Signature\n  }): string\n\n  /**\n   * Broadcasts a signed transaction to the network.\n   *\n   * @param txSerialized - The serialized signed transaction\n   * @returns Promise resolving to an object containing the transaction hash/ID\n   */\n  abstract broadcastTx(txSerialized: string): Promise<{ hash: string }>\n}\n","// EVM\nexport { EVM } from './EVM'\n\nexport { fetchEVMFeeProperties, type EVMFeeProperties } from './utils'\n\nexport type {\n  EVMTransactionRequest,\n  EVMUnsignedTransaction,\n  EVMMessage,\n  EVMTypedData,\n  EVMTransactionRequestLegacy,\n  EVMUnsignedLegacyTransaction,\n  EVMAuthorizationRequest,\n  UserOperationV6,\n  UserOperationV7,\n} from './types'\n","import { type PublicClient, type TransactionRequest } from 'viem'\n\nexport interface EVMFeeProperties {\n  gas: bigint\n  maxFeePerGas: bigint\n  maxPriorityFeePerGas: bigint\n}\n\nexport async function fetchEVMFeeProperties(\n  client: PublicClient,\n  transaction: TransactionRequest\n): Promise<EVMFeeProperties> {\n  const gasPromise = transaction.gas\n    ? Promise.resolve(transaction.gas)\n    : client.estimateGas({ account: transaction.from, ...transaction })\n  const feeDataPromise =\n    transaction.maxFeePerGas && transaction.maxPriorityFeePerGas\n      ? Promise.resolve({\n          maxFeePerGas: transaction.maxFeePerGas,\n          maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,\n        })\n      : client.estimateFeesPerGas()\n\n  const [gas, feeData] = await Promise.all([gasPromise, feeDataPromise])\n\n  const maxFeePerGas = feeData.maxFeePerGas ?? BigInt(10_000_000_000) // 10 gwei\n  const maxPriorityFeePerGas =\n    feeData.maxPriorityFeePerGas ?? BigInt(10_000_000_000) // 10 gwei\n\n  return {\n    gas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n  }\n}\n","import {\n  parseTransaction,\n  type PublicClient,\n  hashMessage,\n  hashTypedData,\n  keccak256,\n  toBytes,\n  type Hex,\n  serializeTransaction,\n  type Signature,\n  numberToHex,\n  getAddress,\n  type Address,\n  type Hash,\n  concatHex,\n  encodeAbiParameters,\n  hexToBigInt,\n  concat,\n  pad,\n  isAddress,\n  type SignedAuthorization,\n} from 'viem'\nimport { hashAuthorization } from 'viem/experimental'\n\nimport { ChainAdapter } from '@chain-adapters/ChainAdapter'\nimport type {\n  EVMTransactionRequest,\n  EVMUnsignedTransaction,\n  EVMMessage,\n  EVMTypedData,\n  UserOperationV6,\n  UserOperationV7,\n  EVMAuthorizationRequest,\n  EVMTransactionRequestLegacy,\n  EVMUnsignedLegacyTransaction,\n} from '@chain-adapters/EVM/types'\nimport { fetchEVMFeeProperties } from '@chain-adapters/EVM/utils'\nimport type { ChainSignatureContract } from '@contracts/ChainSignatureContract'\nimport type { HashToSign, RSVSignature } from '@types'\n\n/**\n * Implementation of the ChainAdapter interface for EVM-compatible networks.\n * Handles interactions with Ethereum Virtual Machine based blockchains like Ethereum, BSC, Polygon, etc.\n */\nexport class EVM extends ChainAdapter<EVMTransactionRequest, EVMUnsignedTransaction> {\n  private readonly client: PublicClient\n  private readonly contract: ChainSignatureContract\n\n  /**\n   * Creates a new EVM chain instance\n   * @param params - Configuration parameters\n   * @param params.publicClient - A Viem PublicClient instance for reading from the blockchain\n   * @param params.contract - Instance of the chain signature contract for MPC operations\n   */\n  constructor({\n    publicClient,\n    contract,\n  }: {\n    publicClient: PublicClient\n    contract: ChainSignatureContract\n  }) {\n    super()\n\n    this.contract = contract\n    this.client = publicClient\n  }\n\n  private async attachGasAndNonce(\n    transaction: EVMTransactionRequest\n  ): Promise<EVMUnsignedTransaction> {\n    const fees = await fetchEVMFeeProperties(this.client, transaction)\n    const nonce =\n      transaction.nonce ??\n      (await this.client.getTransactionCount({\n        address: transaction.from,\n      }))\n\n    const { from, ...rest } = transaction\n\n    return {\n      ...fees,\n      nonce,\n      chainId: Number(await this.client.getChainId()),\n      type: 'eip1559',\n      ...rest,\n    }\n  }\n\n  private async attachGasAndNonceLegacy(\n    transaction: EVMTransactionRequestLegacy\n  ): Promise<EVMUnsignedLegacyTransaction> {\n    const gasPrice = transaction.gasPrice ?? (await this.client.getGasPrice())\n    const nonce =\n      transaction.nonce ??\n      (await this.client.getTransactionCount({\n        address: transaction.from,\n      }))\n\n    const { from, ...rest } = transaction\n\n    return {\n      ...rest,\n      gasPrice: BigInt(gasPrice),\n      nonce: Number(nonce),\n      value: rest.value !== undefined ? BigInt(rest.value) : undefined,\n      gas: rest.gas !== undefined ? BigInt(rest.gas) : BigInt(21000),\n      chainId: await this.client.getChainId(),\n      type: 'legacy',\n    }\n  }\n\n  private transformRSVSignature(signature: RSVSignature): Signature {\n    return {\n      r: `0x${signature.r}`,\n      s: `0x${signature.s}`,\n      yParity: signature.v - 27,\n    }\n  }\n\n  private assembleSignature(signature: RSVSignature): Hex {\n    const { r, s, yParity } = this.transformRSVSignature(signature)\n\n    if (yParity === undefined) {\n      throw new Error('Missing yParity')\n    }\n\n    return concatHex([r, s, numberToHex(yParity + 27, { size: 1 })])\n  }\n\n  async deriveAddressAndPublicKey(\n    predecessor: string,\n    path: string\n  ): Promise<{\n    address: string\n    publicKey: string\n  }> {\n    const uncompressedPubKey = await this.contract.getDerivedPublicKey({\n      path,\n      predecessor,\n    })\n\n    if (!uncompressedPubKey) {\n      throw new Error('Failed to get derived public key')\n    }\n\n    const publicKeyNoPrefix = uncompressedPubKey.startsWith('04')\n      ? uncompressedPubKey.slice(2)\n      : uncompressedPubKey\n\n    const hash = keccak256(Buffer.from(publicKeyNoPrefix, 'hex'))\n    const address = getAddress(`0x${hash.slice(-40)}`)\n\n    return {\n      address,\n      publicKey: uncompressedPubKey,\n    }\n  }\n\n  async getBalance(\n    address: string\n  ): Promise<{ balance: bigint; decimals: number }> {\n    const balance = await this.client.getBalance({\n      address: address as Address,\n    })\n    return {\n      balance,\n      decimals: 18,\n    }\n  }\n\n  serializeTransaction(transaction: EVMUnsignedTransaction): `0x${string}` {\n    return serializeTransaction(transaction)\n  }\n\n  deserializeTransaction(serialized: `0x${string}`): EVMUnsignedTransaction {\n    return parseTransaction(serialized) as EVMUnsignedTransaction\n  }\n\n  async prepareTransactionForSigning(\n    transactionRequest: EVMTransactionRequest\n  ): Promise<{\n    transaction: EVMUnsignedTransaction\n    hashesToSign: HashToSign[]\n  }> {\n    const transaction = await this.attachGasAndNonce(transactionRequest)\n\n    const serializedTx = serializeTransaction(transaction)\n    const txHash = toBytes(keccak256(serializedTx))\n\n    return {\n      transaction,\n      hashesToSign: [Array.from(txHash)],\n    }\n  }\n\n  async prepareTransactionForSigningLegacy(\n    transactionRequest: EVMTransactionRequestLegacy\n  ): Promise<{\n    transaction: EVMUnsignedLegacyTransaction\n    hashesToSign: HashToSign[]\n  }> {\n    const transaction = await this.attachGasAndNonceLegacy(transactionRequest)\n    const serializedTx = serializeTransaction(transaction)\n    const txHash = toBytes(keccak256(serializedTx))\n    return {\n      transaction,\n      hashesToSign: [Array.from(txHash)],\n    }\n  }\n\n  async prepareMessageForSigning(message: EVMMessage): Promise<{\n    hashToSign: HashToSign\n  }> {\n    return {\n      hashToSign: Array.from(toBytes(hashMessage(message))),\n    }\n  }\n\n  async prepareTypedDataForSigning(typedDataRequest: EVMTypedData): Promise<{\n    hashToSign: HashToSign\n  }> {\n    return {\n      hashToSign: Array.from(toBytes(hashTypedData(typedDataRequest))),\n    }\n  }\n\n  /**\n   * This implementation is a common step for Biconomy and Alchemy.\n   * Key differences between implementations:\n   * - Signature format: Biconomy omits 0x00 prefix when concatenating, Alchemy includes it\n   * - Version support: Biconomy only supports v6, Alchemy supports both v6 and v7\n   * - Validation: Biconomy uses modules for signature validation, Alchemy uses built-in validation\n   */\n  async prepareUserOpForSigning(\n    userOp: UserOperationV7 | UserOperationV6,\n    entryPointAddress?: Address,\n    chainIdArgs?: number\n  ): Promise<{\n    userOp: UserOperationV7 | UserOperationV6\n    hashToSign: HashToSign\n  }> {\n    const chainId = chainIdArgs ?? (await this.client.getChainId())\n    const entryPoint =\n      entryPointAddress || '0x0000000071727De22E5E9d8BAf0edAc6f37da032'\n\n    const encoded = encodeAbiParameters(\n      [{ type: 'bytes32' }, { type: 'address' }, { type: 'uint256' }],\n      [\n        keccak256(\n          encodeAbiParameters(\n            [\n              { type: 'address' },\n              { type: 'uint256' },\n              { type: 'bytes32' },\n              { type: 'bytes32' },\n              { type: 'bytes32' },\n              { type: 'uint256' },\n              { type: 'bytes32' },\n              { type: 'bytes32' },\n            ],\n            [\n              userOp.sender,\n              hexToBigInt(userOp.nonce),\n              keccak256(\n                'factory' in userOp &&\n                  'factoryData' in userOp &&\n                  userOp.factory &&\n                  userOp.factoryData\n                  ? concat([userOp.factory, userOp.factoryData])\n                  : 'initCode' in userOp\n                    ? userOp.initCode\n                    : '0x'\n              ),\n              keccak256(userOp.callData),\n              concat([\n                pad(userOp.verificationGasLimit, { size: 16 }),\n                pad(userOp.callGasLimit, { size: 16 }),\n              ]),\n              hexToBigInt(userOp.preVerificationGas),\n              concat([\n                pad(userOp.maxPriorityFeePerGas, { size: 16 }),\n                pad(userOp.maxFeePerGas, { size: 16 }),\n              ]),\n              keccak256(\n                'paymaster' in userOp &&\n                  userOp.paymaster &&\n                  isAddress(userOp.paymaster)\n                  ? concat([\n                      userOp.paymaster,\n                      pad(userOp.paymasterVerificationGasLimit, { size: 16 }),\n                      pad(userOp.paymasterPostOpGasLimit, { size: 16 }),\n                      userOp.paymasterData,\n                    ])\n                  : 'paymasterAndData' in userOp\n                    ? userOp.paymasterAndData\n                    : '0x'\n              ),\n            ]\n          )\n        ),\n        entryPoint,\n        BigInt(chainId),\n      ]\n    )\n\n    const userOpHash = keccak256(encoded)\n\n    return {\n      userOp,\n      hashToSign: Array.from(toBytes(hashMessage({ raw: userOpHash }))),\n    }\n  }\n\n  prepareAuthorizationForSigning(params: EVMAuthorizationRequest): {\n    hashToSign: HashToSign\n  } {\n    const address = params.contractAddress ?? params.address\n    return {\n      hashToSign: Array.from(\n        toBytes(\n          hashAuthorization({\n            address,\n            chainId: params.chainId,\n            nonce: params.nonce,\n          })\n        )\n      ),\n    }\n  }\n\n  finalizeTransactionSigning({\n    transaction,\n    rsvSignatures,\n  }: {\n    transaction: EVMUnsignedTransaction\n    rsvSignatures: RSVSignature[]\n  }): `0x02${string}` {\n    const signature = this.transformRSVSignature(rsvSignatures[0])\n\n    return serializeTransaction(transaction, signature)\n  }\n\n  public finalizeTransactionSigningLegacy({\n    transaction,\n    rsvSignatures,\n  }: {\n    transaction: EVMUnsignedLegacyTransaction\n    rsvSignatures: RSVSignature[]\n  }): `0x${string}` {\n    const signature = {\n      v: BigInt(rsvSignatures[0].v),\n      r: `0x${rsvSignatures[0].r.padStart(64, '0')}` as `0x${string}`,\n      s: `0x${rsvSignatures[0].s.padStart(64, '0')}` as `0x${string}`,\n      yParity: rsvSignatures[0].v - 27,\n    }\n\n    return serializeTransaction(transaction, signature)\n  }\n\n  finalizeMessageSigning({\n    rsvSignature,\n  }: {\n    rsvSignature: RSVSignature\n  }): Hex {\n    return this.assembleSignature(rsvSignature)\n  }\n\n  finalizeTypedDataSigning({\n    rsvSignature,\n  }: {\n    rsvSignature: RSVSignature\n  }): Hex {\n    return this.assembleSignature(rsvSignature)\n  }\n\n  finalizeUserOpSigning({\n    userOp,\n    rsvSignature,\n  }: {\n    userOp: UserOperationV7 | UserOperationV6\n    rsvSignature: RSVSignature\n  }): UserOperationV7 | UserOperationV6 {\n    const { r, s, yParity } = this.transformRSVSignature(rsvSignature)\n    if (yParity === undefined) {\n      throw new Error('Missing yParity')\n    }\n\n    return {\n      ...userOp,\n      signature: concatHex([\n        '0x00', // Alchemy specific implementation. Biconomy doesn't include the 0x00 prefix.\n        r,\n        s,\n        numberToHex(Number(yParity + 27), { size: 1 }),\n      ]),\n    }\n  }\n\n  finalizeAuthorizationSigning(params: {\n    authorization: EVMAuthorizationRequest\n    rsvSignature: RSVSignature\n  }): SignedAuthorization {\n    return {\n      address:\n        params.authorization.contractAddress ?? params.authorization.address,\n      chainId: params.authorization.chainId,\n      nonce: params.authorization.nonce,\n      ...this.transformRSVSignature(params.rsvSignature),\n    }\n  }\n\n  async broadcastTx(txSerialized: string): Promise<{ hash: Hash }> {\n    try {\n      const hash = await this.client.sendRawTransaction({\n        serializedTransaction: txSerialized as `0x${string}`,\n      })\n      return { hash }\n    } catch (error) {\n      console.error('Transaction broadcast failed:', error)\n      throw new Error('Failed to broadcast transaction.')\n    }\n  }\n}\n","// Bitcoin\nexport { Bitcoin } from './Bitcoin'\n\nexport { BTCRpcAdapters, BTCRpcAdapter } from './BTCRpcAdapter'\n\nexport type {\n  BTCTransactionRequest,\n  BTCUnsignedTransaction,\n  BTCTransaction,\n  BTCOutput,\n  BTCInput,\n  BTCNetworkIds,\n} from './types'\n\nexport { Mempool } from './BTCRpcAdapter/Mempool'\n","import * as bitcoin from 'bitcoinjs-lib'\n\nimport { type BTCRpcAdapter } from '@chain-adapters/Bitcoin/BTCRpcAdapter'\nimport type {\n  BTCInput,\n  BTCNetworkIds,\n  BTCOutput,\n  BTCTransactionRequest,\n  BTCUnsignedTransaction,\n} from '@chain-adapters/Bitcoin/types'\nimport { parseBTCNetwork } from '@chain-adapters/Bitcoin/utils'\nimport { ChainAdapter } from '@chain-adapters/ChainAdapter'\nimport type { ChainSignatureContract } from '@contracts/ChainSignatureContract'\nimport type { HashToSign, RSVSignature, UncompressedPubKeySEC1 } from '@types'\nimport { cryptography } from '@utils'\n\n/**\n * Implementation of the ChainAdapter interface for Bitcoin network.\n * Handles interactions with both Bitcoin mainnet and testnet, supporting P2WPKH transactions.\n */\nexport class Bitcoin extends ChainAdapter<\n  BTCTransactionRequest,\n  BTCUnsignedTransaction\n> {\n  private static readonly SATOSHIS_PER_BTC = 100_000_000\n\n  private readonly network: BTCNetworkIds\n  private readonly btcRpcAdapter: BTCRpcAdapter\n  private readonly contract: ChainSignatureContract\n\n  /**\n   * Creates a new Bitcoin chain instance\n   * @param params - Configuration parameters\n   * @param params.network - Network identifier (mainnet/testnet)\n   * @param params.contract - Instance of the chain signature contract for MPC operations\n   * @param params.btcRpcAdapter - Bitcoin RPC adapter for network interactions\n   */\n  constructor({\n    network,\n    contract,\n    btcRpcAdapter,\n  }: {\n    network: BTCNetworkIds\n    contract: ChainSignatureContract\n    btcRpcAdapter: BTCRpcAdapter\n  }) {\n    super()\n\n    this.network = network\n    this.btcRpcAdapter = btcRpcAdapter\n    this.contract = contract\n  }\n\n  /**\n   * Converts satoshis to BTC\n   * @param satoshis - Amount in satoshis\n   * @returns Amount in BTC\n   */\n  static toBTC(satoshis: number): number {\n    return satoshis / Bitcoin.SATOSHIS_PER_BTC\n  }\n\n  /**\n   * Converts BTC to satoshis\n   * @param btc - Amount in BTC\n   * @returns Amount in satoshis (rounded)\n   */\n  static toSatoshi(btc: number): number {\n    return Math.round(btc * Bitcoin.SATOSHIS_PER_BTC)\n  }\n\n  private async fetchTransaction(\n    transactionId: string\n  ): Promise<bitcoin.Transaction> {\n    const data = await this.btcRpcAdapter.getTransaction(transactionId)\n    const tx = new bitcoin.Transaction()\n\n    data.vout.forEach((vout) => {\n      const scriptPubKey = Buffer.from(vout.scriptpubkey, 'hex')\n      tx.addOutput(scriptPubKey, Number(vout.value))\n    })\n\n    return tx\n  }\n\n  private static transformRSVSignature(signature: RSVSignature): Buffer {\n    const r = signature.r.padStart(64, '0')\n    const s = signature.s.padStart(64, '0')\n\n    const rawSignature = Buffer.from(r + s, 'hex')\n\n    if (rawSignature.length !== 64) {\n      throw new Error('Invalid signature length.')\n    }\n\n    return rawSignature\n  }\n\n  /**\n   * Creates a Partially Signed Bitcoin Transaction (PSBT)\n   * @param params - Parameters for creating the PSBT\n   * @param params.transactionRequest - Transaction request containing inputs and outputs\n   * @returns Created PSBT instance\n   */\n  async createPSBT({\n    transactionRequest,\n  }: {\n    transactionRequest: BTCTransactionRequest\n  }): Promise<bitcoin.Psbt> {\n    const { inputs, outputs } =\n      transactionRequest.inputs && transactionRequest.outputs\n        ? transactionRequest\n        : await this.btcRpcAdapter.selectUTXOs(transactionRequest.from, [\n            {\n              address: transactionRequest.to,\n              value: parseFloat(transactionRequest.value),\n            },\n          ])\n\n    const psbt = new bitcoin.Psbt({ network: parseBTCNetwork(this.network) })\n\n    await Promise.all(\n      inputs.map(async (input: BTCInput) => {\n        if (!input.scriptPubKey) {\n          const transaction = await this.fetchTransaction(input.txid)\n          const prevOut = transaction.outs[input.vout]\n          input.scriptPubKey = prevOut.script\n        }\n\n        // Prepare the input as P2WPKH\n        psbt.addInput({\n          hash: input.txid,\n          index: input.vout,\n          witnessUtxo: {\n            script: input.scriptPubKey,\n            value: input.value,\n          },\n        })\n      })\n    )\n\n    outputs.forEach((out: BTCOutput) => {\n      if ('address' in out) {\n        psbt.addOutput({\n          address: out.address,\n          value: out.value,\n        })\n      } else if ('script' in out) {\n        psbt.addOutput({\n          script: out.script,\n          value: out.value,\n        })\n      } else if (transactionRequest.from !== undefined) {\n        // Include change address from coinselect\n        psbt.addOutput({\n          value: Number(out.value),\n          address: transactionRequest.from,\n        })\n      }\n    })\n\n    return psbt\n  }\n\n  async getBalance(\n    address: string\n  ): Promise<{ balance: bigint; decimals: number }> {\n    const balance = BigInt(await this.btcRpcAdapter.getBalance(address))\n    return {\n      balance,\n      decimals: 8,\n    }\n  }\n\n  async deriveAddressAndPublicKey(\n    predecessor: string,\n    path: string\n  ): Promise<{ address: string; publicKey: string }> {\n    const uncompressedPubKey = await this.contract.getDerivedPublicKey({\n      path,\n      predecessor,\n    })\n\n    if (!uncompressedPubKey) {\n      throw new Error('Failed to get derived public key')\n    }\n\n    const derivedKey = cryptography.compressPubKey(\n      uncompressedPubKey as UncompressedPubKeySEC1\n    )\n    const publicKeyBuffer = Buffer.from(derivedKey, 'hex')\n    const network = parseBTCNetwork(this.network)\n\n    const payment = bitcoin.payments.p2wpkh({\n      pubkey: publicKeyBuffer,\n      network,\n    })\n\n    const { address } = payment\n\n    if (!address) {\n      throw new Error('Failed to generate Bitcoin address')\n    }\n\n    return { address, publicKey: derivedKey }\n  }\n\n  serializeTransaction(transaction: BTCUnsignedTransaction): string {\n    return JSON.stringify({\n      psbt: transaction.psbt.toHex(),\n      publicKey: transaction.publicKey,\n    })\n  }\n\n  deserializeTransaction(serialized: string): BTCUnsignedTransaction {\n    const transactionJSON = JSON.parse(serialized)\n    return {\n      psbt: bitcoin.Psbt.fromHex(transactionJSON.psbt as string),\n      publicKey: transactionJSON.publicKey,\n    }\n  }\n\n  async prepareTransactionForSigning(\n    transactionRequest: BTCTransactionRequest\n  ): Promise<{\n    transaction: BTCUnsignedTransaction\n    hashesToSign: HashToSign[]\n  }> {\n    const publicKeyBuffer = Buffer.from(transactionRequest.publicKey, 'hex')\n    const psbt = await this.createPSBT({\n      transactionRequest,\n    })\n    // We can't double sign a PSBT, therefore we serialize the payload before to return it\n    const psbtHex = psbt.toHex()\n\n    const hashesToSign: HashToSign[] = []\n\n    const mockKeyPair = (index: number): bitcoin.Signer => ({\n      publicKey: publicKeyBuffer,\n      sign: (hash: Buffer): Buffer => {\n        hashesToSign[index] = Array.from(hash)\n        // Return dummy signature to satisfy the interface\n        return Buffer.alloc(64)\n      },\n    })\n\n    for (let index = 0; index < psbt.inputCount; index++) {\n      psbt.signInput(index, mockKeyPair(index))\n    }\n\n    return {\n      transaction: {\n        psbt: bitcoin.Psbt.fromHex(psbtHex),\n        publicKey: transactionRequest.publicKey,\n      },\n      hashesToSign,\n    }\n  }\n\n  finalizeTransactionSigning({\n    transaction: { psbt, publicKey },\n    rsvSignatures,\n  }: {\n    transaction: BTCUnsignedTransaction\n    rsvSignatures: RSVSignature[]\n  }): string {\n    const publicKeyBuffer = Buffer.from(publicKey, 'hex')\n\n    const keyPair = (index: number): bitcoin.Signer => ({\n      publicKey: publicKeyBuffer,\n      sign: () => {\n        const mpcSignature = rsvSignatures[index]\n        return Bitcoin.transformRSVSignature(mpcSignature)\n      },\n    })\n\n    for (let index = 0; index < psbt.inputCount; index++) {\n      psbt.signInput(index, keyPair(index))\n    }\n\n    psbt.finalizeAllInputs()\n    return psbt.extractTransaction().toHex()\n  }\n\n  async broadcastTx(txSerialized: string): Promise<{ hash: string }> {\n    const txId = await this.btcRpcAdapter.broadcastTransaction(txSerialized)\n    return { hash: txId }\n  }\n}\n","import * as bitcoin from 'bitcoinjs-lib'\n\nexport function parseBTCNetwork(network: string): bitcoin.networks.Network {\n  switch (network.toLowerCase()) {\n    case 'mainnet':\n      return bitcoin.networks.bitcoin\n    case 'testnet':\n      return bitcoin.networks.testnet\n    case 'regtest':\n      return bitcoin.networks.regtest\n    default:\n      throw new Error(`Unknown Bitcoin network: ${network}`)\n  }\n}\n","import type {\n  BTCTransaction,\n  BTCInput,\n  BTCOutput,\n} from '@chain-adapters/Bitcoin/types'\n\nexport abstract class BTCRpcAdapter {\n  abstract selectUTXOs(\n    from: string,\n    targets: BTCOutput[]\n  ): Promise<{ inputs: BTCInput[]; outputs: BTCOutput[] }>\n  abstract broadcastTransaction(transactionHex: string): Promise<string>\n  abstract getBalance(address: string): Promise<number>\n  abstract getTransaction(txid: string): Promise<BTCTransaction>\n}\n","// There is no types for coinselect\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-expect-error\n\nimport coinselect from 'coinselect'\n\nimport { BTCRpcAdapter } from '@chain-adapters/Bitcoin/BTCRpcAdapter/BTCRpcAdapter'\nimport {\n  type BTCFeeRecommendation,\n  type UTXO,\n} from '@chain-adapters/Bitcoin/BTCRpcAdapter/Mempool/types'\nimport type {\n  BTCTransaction,\n  BTCInput,\n  BTCOutput,\n} from '@chain-adapters/Bitcoin/types'\n\nexport class Mempool extends BTCRpcAdapter {\n  private readonly providerUrl: string\n\n  constructor(providerUrl: string) {\n    super()\n    this.providerUrl = providerUrl\n  }\n\n  private async fetchFeeRate(confirmationTarget = 6): Promise<number> {\n    const response = await fetch(`${this.providerUrl}/v1/fees/recommended`)\n    const data = (await response.json()) as BTCFeeRecommendation\n\n    if (confirmationTarget <= 1) {\n      return data.fastestFee\n    } else if (confirmationTarget <= 3) {\n      return data.halfHourFee\n    } else if (confirmationTarget <= 6) {\n      return data.hourFee\n    } else {\n      return data.economyFee\n    }\n  }\n\n  private async fetchUTXOs(address: string): Promise<UTXO[]> {\n    try {\n      const response = await fetch(\n        `${this.providerUrl}/address/${address}/utxo`\n      )\n      return (await response.json()) as UTXO[]\n    } catch (error) {\n      console.error('Failed to fetch UTXOs:', error)\n      return []\n    }\n  }\n\n  async selectUTXOs(\n    from: string,\n    targets: BTCOutput[],\n    confirmationTarget = 6\n  ): Promise<{ inputs: BTCInput[]; outputs: BTCOutput[] }> {\n    const utxos = await this.fetchUTXOs(from)\n    const feeRate = await this.fetchFeeRate(confirmationTarget)\n\n    // Add a small amount to the fee rate to ensure the transaction is confirmed\n    const ret = coinselect(utxos, targets, Math.ceil(feeRate + 1))\n\n    if (!ret.inputs || !ret.outputs) {\n      throw new Error(\n        'Invalid transaction: coinselect failed to find a suitable set of inputs and outputs. This could be due to insufficient funds, or no inputs being available that meet the criteria.'\n      )\n    }\n\n    return {\n      inputs: ret.inputs,\n      outputs: ret.outputs,\n    }\n  }\n\n  async broadcastTransaction(transactionHex: string): Promise<string> {\n    const response = await fetch(`${this.providerUrl}/tx`, {\n      method: 'POST',\n      body: transactionHex,\n    })\n\n    if (response.ok) {\n      return await response.text()\n    }\n\n    throw new Error(`Failed to broadcast transaction: ${await response.text()}`)\n  }\n\n  async getBalance(address: string): Promise<number> {\n    const response = await fetch(`${this.providerUrl}/address/${address}`)\n    const data = (await response.json()) as {\n      chain_stats: { funded_txo_sum: number; spent_txo_sum: number }\n    }\n    return data.chain_stats.funded_txo_sum - data.chain_stats.spent_txo_sum\n  }\n\n  async getTransaction(txid: string): Promise<BTCTransaction> {\n    const response = await fetch(`${this.providerUrl}/tx/${txid}`)\n    return (await response.json()) as BTCTransaction\n  }\n}\n","import { Mempool } from './Mempool'\nexport { BTCRpcAdapter } from './BTCRpcAdapter'\n\nexport const BTCRpcAdapters = {\n  Mempool,\n}\n","// Cosmos\nexport { Cosmos } from './Cosmos'\n\nexport type {\n  CosmosNetworkIds,\n  CosmosTransactionRequest,\n  CosmosUnsignedTransaction,\n} from './types'\n","import { chains, assets } from 'chain-registry'\n\nimport { type ChainInfo } from '@chain-adapters/Cosmos/types'\n\nexport const fetchChainInfo = async (chainId: string): Promise<ChainInfo> => {\n  const chainInfo = chains.find((chain) => chain.chain_id === chainId)\n  if (!chainInfo) {\n    throw new Error(`Chain info not found for chainId: ${chainId}`)\n  }\n\n  const { bech32_prefix: prefix, chain_id: expectedChainId } = chainInfo\n  const denom = chainInfo.staking?.staking_tokens?.[0]?.denom\n  const rpcUrl = chainInfo.apis?.rpc?.[0]?.address\n  const restUrl = chainInfo.apis?.rest?.[0]?.address\n  const gasPrice = chainInfo.fees?.fee_tokens?.[0]?.average_gas_price\n\n  if (\n    !prefix ||\n    !denom ||\n    !rpcUrl ||\n    !restUrl ||\n    !expectedChainId ||\n    gasPrice === undefined\n  ) {\n    throw new Error(\n      `Missing required chain information for ${chainInfo.chain_name}`\n    )\n  }\n\n  const assetList = assets.find(\n    (asset) => asset.chain_name === chainInfo.chain_name\n  )\n  const asset = assetList?.assets.find((asset) => asset.base === denom)\n  const decimals = asset?.denom_units.find(\n    (unit) => unit.denom === asset.display\n  )?.exponent\n\n  if (decimals === undefined) {\n    throw new Error(\n      `Could not find decimals for ${denom} on chain ${chainInfo.chain_name}`\n    )\n  }\n\n  return { prefix, denom, rpcUrl, restUrl, expectedChainId, gasPrice, decimals }\n}\n","import { encodeSecp256k1Pubkey } from '@cosmjs/amino'\nimport { ripemd160, sha256 } from '@cosmjs/crypto'\nimport { toBase64, fromBase64, fromHex } from '@cosmjs/encoding'\nimport {\n  Registry,\n  makeSignBytes,\n  encodePubkey,\n  makeAuthInfoBytes,\n  makeSignDoc,\n  type TxBodyEncodeObject,\n} from '@cosmjs/proto-signing'\nimport { GasPrice, StargateClient, calculateFee } from '@cosmjs/stargate'\nimport { bech32 } from 'bech32'\nimport { SignMode } from 'cosmjs-types/cosmos/tx/signing/v1beta1/signing'\nimport { TxRaw } from 'cosmjs-types/cosmos/tx/v1beta1/tx'\n\nimport { ChainAdapter } from '@chain-adapters/ChainAdapter'\nimport type {\n  CosmosNetworkIds,\n  CosmosTransactionRequest,\n  CosmosUnsignedTransaction,\n  ChainInfo,\n  BalanceResponse,\n} from '@chain-adapters/Cosmos/types'\nimport { fetchChainInfo } from '@chain-adapters/Cosmos/utils'\nimport type { ChainSignatureContract } from '@contracts/ChainSignatureContract'\nimport type { HashToSign, RSVSignature, UncompressedPubKeySEC1 } from '@types'\nimport { cryptography } from '@utils'\n\n/**\n * Implementation of the ChainAdapter interface for Cosmos-based networks.\n * Handles interactions with Cosmos SDK chains like Cosmos Hub, Osmosis, etc.\n */\nexport class Cosmos extends ChainAdapter<\n  CosmosTransactionRequest,\n  CosmosUnsignedTransaction\n> {\n  private readonly registry: Registry\n  private readonly chainId: CosmosNetworkIds\n  private readonly contract: ChainSignatureContract\n  private readonly endpoints?: {\n    rpcUrl?: string\n    restUrl?: string\n  }\n\n  /**\n   * Creates a new Cosmos chain instance\n   * @param params - Configuration parameters\n   * @param params.chainId - Chain id for the Cosmos network\n   * @param params.contract - Instance of the chain signature contract for MPC operations\n   * @param params.endpoints - Optional RPC and REST endpoints\n   * @param params.endpoints.rpcUrl - Optional RPC endpoint URL\n   * @param params.endpoints.restUrl - Optional REST endpoint URL\n   */\n  constructor({\n    chainId,\n    contract,\n    endpoints,\n  }: {\n    contract: ChainSignatureContract\n    chainId: CosmosNetworkIds\n    endpoints?: {\n      rpcUrl?: string\n      restUrl?: string\n    }\n  }) {\n    super()\n\n    this.contract = contract\n    this.registry = new Registry()\n    this.chainId = chainId\n    this.endpoints = endpoints\n  }\n\n  private transformRSVSignature(rsvSignature: RSVSignature): Uint8Array {\n    return new Uint8Array([\n      ...fromHex(rsvSignature.r),\n      ...fromHex(rsvSignature.s),\n    ])\n  }\n\n  private async getChainInfo(): Promise<ChainInfo> {\n    return {\n      ...(await fetchChainInfo(this.chainId)),\n      ...this.endpoints,\n    }\n  }\n\n  async getBalance(\n    address: string\n  ): Promise<{ balance: bigint; decimals: number }> {\n    try {\n      const { restUrl, denom, decimals } = await this.getChainInfo()\n\n      const response = await fetch(\n        `${restUrl}/cosmos/bank/v1beta1/balances/${address}`\n      )\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`)\n      }\n\n      const data = (await response.json()) as BalanceResponse\n      const balance = data.balances.find((b) => b.denom === denom)\n      const amount = balance?.amount ?? '0'\n\n      return {\n        balance: BigInt(amount),\n        decimals,\n      }\n    } catch (error) {\n      console.error('Failed to fetch Cosmos balance:', error)\n      throw new Error('Failed to fetch Cosmos balance')\n    }\n  }\n\n  async deriveAddressAndPublicKey(\n    predecessor: string,\n    path: string\n  ): Promise<{\n    address: string\n    publicKey: string\n  }> {\n    const { prefix } = await this.getChainInfo()\n    const uncompressedPubKey = await this.contract.getDerivedPublicKey({\n      path,\n      predecessor,\n    })\n\n    if (!uncompressedPubKey) {\n      throw new Error('Failed to get derived public key')\n    }\n\n    const derivedKey = cryptography.compressPubKey(\n      uncompressedPubKey as UncompressedPubKeySEC1\n    )\n    const pubKeySha256 = sha256(fromHex(derivedKey))\n    const ripemd160Hash = ripemd160(pubKeySha256)\n    const address = bech32.encode(prefix, bech32.toWords(ripemd160Hash))\n\n    return { address, publicKey: derivedKey }\n  }\n\n  serializeTransaction(transaction: CosmosUnsignedTransaction): string {\n    const serialized = TxRaw.encode(transaction).finish()\n    return toBase64(serialized)\n  }\n\n  deserializeTransaction(serialized: string): CosmosUnsignedTransaction {\n    return TxRaw.decode(fromBase64(serialized))\n  }\n\n  async prepareTransactionForSigning(\n    transactionRequest: CosmosTransactionRequest\n  ): Promise<{\n    transaction: CosmosUnsignedTransaction\n    hashesToSign: HashToSign[]\n  }> {\n    const { denom, rpcUrl, gasPrice } = await this.getChainInfo()\n    const publicKeyBytes = fromHex(transactionRequest.publicKey)\n\n    const gasLimit = transactionRequest.gas || 200_000\n\n    const fee = calculateFee(\n      gasLimit,\n      GasPrice.fromString(`${gasPrice}${denom}`)\n    )\n\n    const client = await StargateClient.connect(rpcUrl)\n    const accountOnChain = await client.getAccount(transactionRequest.address)\n    if (!accountOnChain) {\n      throw new Error(\n        `Account ${transactionRequest.address} does not exist on chain`\n      )\n    }\n\n    const { accountNumber, sequence } = accountOnChain\n\n    const txBodyEncodeObject: TxBodyEncodeObject = {\n      typeUrl: '/cosmos.tx.v1beta1.TxBody',\n      value: {\n        messages: transactionRequest.messages,\n        memo: transactionRequest.memo || '',\n      },\n    }\n\n    const txBodyBytes = this.registry.encode(txBodyEncodeObject)\n\n    const pubkey = encodePubkey(encodeSecp256k1Pubkey(publicKeyBytes))\n\n    // TODO: Allow caller to provide: multiple signers, fee payer, fee granter\n    const authInfoBytes = makeAuthInfoBytes(\n      [\n        {\n          pubkey,\n          sequence,\n        },\n      ],\n      fee.amount,\n      Number(fee.gas),\n      undefined,\n      undefined,\n      SignMode.SIGN_MODE_DIRECT\n    )\n\n    const signDoc = makeSignDoc(\n      txBodyBytes,\n      authInfoBytes,\n      this.chainId,\n      accountNumber\n    )\n\n    const signBytes = makeSignBytes(signDoc)\n    const payload = Array.from(sha256(signBytes))\n\n    return {\n      transaction: TxRaw.fromPartial({\n        bodyBytes: txBodyBytes,\n        authInfoBytes,\n        signatures: [],\n      }),\n      hashesToSign: [payload],\n    }\n  }\n\n  finalizeTransactionSigning({\n    transaction,\n    rsvSignatures,\n  }: {\n    transaction: CosmosUnsignedTransaction\n    rsvSignatures: RSVSignature[]\n  }): string {\n    // Allow support for multi-sig but the package only supports single-sig\n    transaction.signatures = rsvSignatures.map((sig) =>\n      this.transformRSVSignature(sig)\n    )\n\n    const txBytes = TxRaw.encode(transaction).finish()\n    return Buffer.from(txBytes).toString('hex')\n  }\n\n  // @ts-expect-error - TODO: fix this\n  async broadcastTx(txSerialized: string): Promise<string> {\n    try {\n      const { rpcUrl } = await this.getChainInfo()\n      const client = await StargateClient.connect(rpcUrl)\n\n      const txBytes = fromHex(txSerialized)\n      const broadcastResponse = await client.broadcastTx(txBytes)\n\n      if (broadcastResponse.code !== 0) {\n        throw new Error(`Broadcast error: ${broadcastResponse.rawLog}`)\n      }\n\n      return broadcastResponse.transactionHash\n    } catch (error) {\n      console.error('Transaction broadcast failed:', error)\n      throw new Error('Failed to broadcast transaction.')\n    }\n  }\n}\n","export * from './Solana'\nexport * from './types'\n","import type { Connection as SolanaConnection } from '@solana/web3.js'\nimport { PublicKey, Transaction, SystemProgram } from '@solana/web3.js'\nimport type BN from 'bn.js'\n\nimport type { ChainSignatureContract } from '@contracts/ChainSignatureContract'\nimport type { HashToSign, Signature } from '@types'\n\nimport { ChainAdapter } from '../ChainAdapter'\n\nimport type {\n  SolanaTransactionRequest,\n  SolanaUnsignedTransaction,\n} from './types'\n\nconst toBigInt = (value: bigint | BN): bigint => {\n  if (typeof value === 'bigint') return value\n  return BigInt(value.toString())\n}\n\nexport class Solana extends ChainAdapter<\n  SolanaTransactionRequest,\n  SolanaUnsignedTransaction\n> {\n  private readonly connection: SolanaConnection\n  private readonly contract: ChainSignatureContract\n\n  constructor(args: {\n    solanaConnection: SolanaConnection\n    contract: ChainSignatureContract\n  }) {\n    super()\n    this.connection = args.solanaConnection\n    this.contract = args.contract\n  }\n\n  async getBalance(\n    address: string\n  ): Promise<{ balance: bigint; decimals: number }> {\n    const pubkey = new PublicKey(address)\n    const balance = await this.connection.getBalance(pubkey)\n    return {\n      balance: BigInt(balance),\n      decimals: 9, // Solana uses 9 decimals (LAMPORTS_PER_SOL)\n    }\n  }\n\n  async deriveAddressAndPublicKey(\n    predecessor: string,\n    path: string\n  ): Promise<{ address: string; publicKey: string }> {\n    const pubKey = await this.contract.getDerivedPublicKey({\n      path,\n      predecessor,\n      IsEd25519: true,\n    })\n\n    const base58Key = pubKey.replace('ed25519:', '')\n    const publicKey = new PublicKey(base58Key)\n\n    return {\n      address: publicKey.toBase58(),\n      publicKey: publicKey.toString(),\n    }\n  }\n\n  serializeTransaction(transaction: SolanaUnsignedTransaction): string {\n    return Buffer.from(\n      transaction.transaction.serialize({\n        requireAllSignatures: false,\n      })\n    ).toString('base64')\n  }\n\n  deserializeTransaction(serialized: string): SolanaUnsignedTransaction {\n    const buffer = Buffer.from(serialized, 'base64')\n    const transaction = Transaction.from(buffer)\n\n    return {\n      transaction,\n      feePayer:\n        transaction.feePayer ||\n        new PublicKey('11111111111111111111111111111111'),\n      recentBlockhash: transaction.recentBlockhash || '',\n    }\n  }\n\n  async prepareTransactionForSigning(\n    request: SolanaTransactionRequest\n  ): Promise<{\n    transaction: SolanaUnsignedTransaction\n    hashesToSign: HashToSign[]\n  }> {\n    const transaction = new Transaction()\n\n    // Add transfer instruction if amount is specified\n    const amount = toBigInt(request.amount)\n    if (amount > 0n) {\n      transaction.add(\n        SystemProgram.transfer({\n          fromPubkey: new PublicKey(request.from),\n          toPubkey: new PublicKey(request.to),\n          lamports: Number(amount),\n        })\n      )\n    }\n\n    // Add any additional instructions\n    if (request.instructions) {\n      transaction.add(...request.instructions)\n    }\n\n    // Get recent blockhash\n    const { blockhash } = await this.connection.getLatestBlockhash()\n    transaction.recentBlockhash = blockhash\n\n    // Set fee payer\n    transaction.feePayer = request.feePayer || new PublicKey(request.from)\n\n    const messageBytes = transaction.compileMessage().serialize()\n\n    return {\n      transaction: {\n        transaction,\n        feePayer: transaction.feePayer,\n        recentBlockhash: blockhash,\n      },\n      hashesToSign: [Array.from(messageBytes)],\n    }\n  }\n\n  finalizeTransactionSigning({\n    transaction,\n    rsvSignatures,\n    senderAddress,\n  }: {\n    transaction: Transaction\n    rsvSignatures: Signature\n    senderAddress: string\n  }): string {\n    const signatureBuffer = Buffer.from(rsvSignatures.signature)\n    transaction.addSignature(new PublicKey(senderAddress), signatureBuffer)\n    return transaction.serialize().toString('base64')\n  }\n\n  async broadcastTx(txSerialized: string): Promise<{ hash: string }> {\n    const transaction = this.deserializeTransaction(txSerialized)\n\n    const signature = await this.connection.sendRawTransaction(\n      transaction.transaction.serialize()\n    )\n\n    return { hash: signature }\n  }\n}\n","export { Aptos } from './Aptos'\n","import {\n  type AccountAuthenticator,\n  AccountAuthenticatorEd25519,\n  type AnyRawTransaction,\n  Deserializer,\n  Ed25519PublicKey,\n  Ed25519Signature,\n  generateSigningMessageForTransaction,\n  MultiAgentTransaction,\n  SimpleTransaction,\n  type Aptos as _Aptos,\n  type PendingTransactionResponse,\n  generateSignedTransaction,\n  postAptosFullNode,\n  SignedTransaction,\n  MimeType,\n  AbstractKeylessAccount,\n  KeylessPublicKey,\n  FederatedKeylessPublicKey,\n  type KeylessSignature,\n} from '@aptos-labs/ts-sdk'\nimport bs58 from 'bs58'\n\nimport { ChainAdapter } from '@chain-adapters/ChainAdapter'\nimport { type ChainSignatureContract } from '@contracts'\nimport { type HashToSign, type Signature } from '@types'\n\nexport class Aptos extends ChainAdapter<AnyRawTransaction, AnyRawTransaction> {\n  private readonly contract: ChainSignatureContract\n  private readonly client: _Aptos\n\n  /**\n   * Creates a new Aptos chain instance\n   * @param params - Configuration parameters\n   * @param params.client - A Aptos client instance to interact with the blockchain\n   * @param params.contract - Instance of the chain signature contract for MPC operations\n   */\n  constructor({\n    contract,\n    client,\n  }: {\n    contract: ChainSignatureContract\n    client: _Aptos\n  }) {\n    super()\n\n    this.contract = contract\n    this.client = client\n  }\n\n  async getBalance(\n    address: string\n  ): Promise<{ balance: bigint; decimals: number }> {\n    const amount = await this.client.account.getAccountAPTAmount({\n      accountAddress: address,\n    })\n\n    return {\n      balance: BigInt(amount),\n      decimals: 8,\n    }\n  }\n\n  async deriveAddressAndPublicKey(\n    predecessor: string,\n    path: string\n  ): Promise<{ address: string; publicKey: string }> {\n    const pubKey = await this.contract.getDerivedPublicKey({\n      path,\n      predecessor,\n      IsEd25519: true,\n    })\n\n    const base58Key = pubKey.replace('ed25519:', '')\n    const bytes = bs58.decode(base58Key)\n    const publicKey = '0x' + Buffer.from(bytes).toString('hex')\n    const address = new Ed25519PublicKey(bytes)\n      .authKey()\n      .derivedAddress()\n      .toString()\n\n    return {\n      address,\n      publicKey,\n    }\n  }\n\n  serializeTransaction(transaction: AnyRawTransaction): string {\n    return transaction.bcsToHex().toString()\n  }\n\n  deserializeTransaction(\n    serialized: string\n  ): MultiAgentTransaction | SimpleTransaction {\n    const isPrefixWith0x = serialized.startsWith('0x')\n\n    const buffer = Buffer.from(\n      isPrefixWith0x ? serialized.slice(2) : serialized,\n      'hex'\n    )\n    try {\n      const deserializer = new Deserializer(buffer)\n      return MultiAgentTransaction.deserialize(deserializer)\n    } catch {\n      // failed to deserialize as MultiAgentTransaction\n      // try multi agent next\n    }\n\n    const deserializer = new Deserializer(buffer)\n    return SimpleTransaction.deserialize(deserializer)\n  }\n\n  async prepareTransactionForSigning(\n    transactionRequest: AnyRawTransaction\n  ): Promise<{ transaction: AnyRawTransaction; hashesToSign: HashToSign[] }> {\n    return {\n      transaction: transactionRequest,\n      hashesToSign: [generateSigningMessageForTransaction(transactionRequest)],\n    }\n  }\n\n  rsvSignatureToSenderAuthenticator(params: {\n    rsvSignatures: Signature\n    publicKey: string\n  }): AccountAuthenticatorEd25519 {\n    const signatureBuffer = Buffer.from(params.rsvSignatures.signature)\n\n    const isPublicKeyPrefixWith0x = params.publicKey.startsWith('0x')\n\n    const publicKeyBuffer = Buffer.from(\n      isPublicKeyPrefixWith0x ? params.publicKey.slice(2) : params.publicKey,\n      'hex'\n    )\n\n    const publicKey = new Ed25519PublicKey(publicKeyBuffer)\n\n    const senderAuthenticator = new AccountAuthenticatorEd25519(\n      publicKey,\n      new Ed25519Signature(signatureBuffer.toString('hex'))\n    )\n\n    return senderAuthenticator\n  }\n\n  finalizeTransactionSigning(params: {\n    transaction: AnyRawTransaction\n    rsvSignatures: Signature\n    publicKey: string\n    additionalSignersAuthenticators?: AccountAuthenticator[]\n    feePayerAuthenticator?: AccountAuthenticator\n  }): string {\n    const senderAuthenticator = this.rsvSignatureToSenderAuthenticator({\n      rsvSignatures: params.rsvSignatures,\n      publicKey: params.publicKey,\n    })\n\n    const signedTx = generateSignedTransaction({\n      transaction: params.transaction,\n      senderAuthenticator,\n      additionalSignersAuthenticators: params.additionalSignersAuthenticators,\n      feePayerAuthenticator: params.feePayerAuthenticator,\n    })\n\n    return '0x' + Buffer.from(signedTx).toString('hex')\n  }\n\n  private deserializeSignedTransaction(\n    serializedSignedTransaction: string\n  ): SignedTransaction {\n    const isPrefixWith0x = serializedSignedTransaction.startsWith('0x')\n    const buffer = Buffer.from(\n      isPrefixWith0x\n        ? serializedSignedTransaction.slice(2)\n        : serializedSignedTransaction,\n      'hex'\n    )\n\n    const deserializer = new Deserializer(buffer)\n\n    const signedTransaction = SignedTransaction.deserialize(deserializer)\n\n    return signedTransaction\n  }\n\n  async broadcastTx(txSerialized: string): Promise<{ hash: string }> {\n    // copy from aptos-ts-sdk, `transactionSubmission.ts` -> `submitTransaction()`\n    const signedTransaction = this.deserializeSignedTransaction(txSerialized)\n\n    try {\n      const { data } = await postAptosFullNode<\n        Uint8Array,\n        PendingTransactionResponse\n      >({\n        aptosConfig: this.client.config,\n        body: signedTransaction.bcsToBytes(),\n        path: 'transactions',\n        originMethod: 'submitTransaction',\n        contentType: MimeType.BCS_SIGNED_TRANSACTION,\n      })\n\n      return {\n        hash: data.hash,\n      }\n    } catch (e) {\n      if (\n        signedTransaction.authenticator.isSingleSender() &&\n        signedTransaction.authenticator.sender.isSingleKey() &&\n        (signedTransaction.authenticator.sender.public_key.publicKey instanceof\n          KeylessPublicKey ||\n          signedTransaction.authenticator.sender.public_key.publicKey instanceof\n            FederatedKeylessPublicKey)\n      ) {\n        await AbstractKeylessAccount.fetchJWK({\n          aptosConfig: this.client.config,\n          publicKey:\n            signedTransaction.authenticator.sender.public_key.publicKey,\n          kid: (\n            signedTransaction.authenticator.sender.signature\n              .signature as KeylessSignature\n          ).getJwkKid(),\n        })\n      }\n      throw e\n    }\n  }\n}\n","export * from './SUI'\nexport * from './types'\n","import { toBase64 } from '@mysten/bcs'\nimport {\n  type SuiClient,\n  SuiHTTPTransport,\n  type SuiTransactionBlockResponse,\n} from '@mysten/sui/client'\nimport {\n  messageWithIntent,\n  toSerializedSignature,\n} from '@mysten/sui/cryptography'\nimport { Ed25519PublicKey } from '@mysten/sui/keypairs/ed25519'\nimport { type Transaction } from '@mysten/sui/transactions'\nimport { blake2b } from '@noble/hashes/blake2b'\nimport bs58 from 'bs58'\n\nimport { ChainAdapter } from '@chain-adapters/ChainAdapter'\nimport { type ChainSignatureContract } from '@contracts'\nimport { type HashToSign, type Signature } from '@types'\n\nimport {\n  type SUITransactionRequest,\n  type SUIUnsignedTransaction,\n} from './types'\n\nexport class SUI extends ChainAdapter<\n  SUITransactionRequest,\n  SUIUnsignedTransaction\n> {\n  private readonly contract: ChainSignatureContract\n  private readonly client: SuiClient\n  private readonly transport: SuiHTTPTransport\n  /**\n   * Creates a new SUI chain instance\n   * @param params - Configuration parameters\n   * @param params.client - A SUI client instance to interact with the blockchain\n   * @param params.contract - Instance of the chain signature contract for MPC operations\n   */\n  constructor({\n    contract,\n    client,\n    rpcUrl,\n  }: {\n    contract: ChainSignatureContract\n    client: SuiClient\n    rpcUrl: string\n  }) {\n    super()\n\n    this.contract = contract\n    this.client = client\n    this.transport = new SuiHTTPTransport({ url: rpcUrl })\n  }\n\n  async getBalance(\n    address: string\n  ): Promise<{ balance: bigint; decimals: number }> {\n    const balance = await this.client.getBalance({\n      owner: address,\n    })\n\n    return {\n      balance: BigInt(balance.totalBalance),\n      decimals: 9,\n    }\n  }\n\n  async deriveAddressAndPublicKey(\n    predecessor: string,\n    path: string\n  ): Promise<{ address: string; publicKey: string }> {\n    const pubKey = await this.contract.getDerivedPublicKey({\n      path,\n      predecessor,\n      IsEd25519: true,\n    })\n\n    const base58Key = pubKey.replace('ed25519:', '')\n    const bytes = bs58.decode(base58Key)\n\n    const pubKeyInSui = new Ed25519PublicKey(bytes)\n\n    return {\n      publicKey: pubKeyInSui.toSuiPublicKey(),\n      address: pubKeyInSui.toSuiAddress(),\n    }\n  }\n\n  serializeTransaction(transaction: Uint8Array<ArrayBufferLike>): string {\n    return Buffer.from(transaction).toString('hex')\n  }\n\n  deserializeTransaction(serialized: string): Uint8Array<ArrayBufferLike> {\n    const buffer = Buffer.from(serialized, 'hex')\n    return new Uint8Array(buffer)\n  }\n\n  async prepareTransactionForSigning(transactionRequest: Transaction): Promise<{\n    transaction: Uint8Array<ArrayBufferLike>\n    hashesToSign: HashToSign[]\n  }> {\n    const txBytes = await transactionRequest.build({\n      client: this.client,\n    })\n    const intent = 'TransactionData'\n\n    const intentMessage = messageWithIntent(intent, txBytes)\n    const digest = blake2b(intentMessage, { dkLen: 32 })\n\n    return {\n      hashesToSign: [digest],\n      transaction: txBytes,\n    }\n  }\n\n  rsvSignatureToSuiSignature(params: {\n    transaction: Uint8Array<ArrayBufferLike>\n    rsvSignatures: Signature\n    publicKey: string\n  }): string {\n    const publicKeyBufferWithPrefix = Buffer.from(params.publicKey, 'base64')\n    const rawPublicKeyBuffer = publicKeyBufferWithPrefix.subarray(1)\n    const signature = toSerializedSignature({\n      signature: Buffer.from(params.rsvSignatures.signature),\n      signatureScheme: 'ED25519',\n      publicKey: new Ed25519PublicKey(rawPublicKeyBuffer),\n    })\n\n    return signature\n  }\n\n  finalizeTransactionSigning(params: {\n    transaction: Uint8Array<ArrayBufferLike>\n    rsvSignatures: Signature\n    publicKey: string\n  }): string {\n    const signature = this.rsvSignatureToSuiSignature(params)\n\n    // doing this as SUI dont have a way to serialize\n    // signature and transaction\n    return JSON.stringify([\n      typeof params.transaction === 'string'\n        ? params.transaction\n        : toBase64(params.transaction),\n      Array.isArray(signature) ? signature : [signature],\n    ])\n  }\n\n  async broadcastTx(txSerialized: string): Promise<{ hash: string }> {\n    const result: SuiTransactionBlockResponse = await this.transport.request({\n      method: 'sui_executeTransactionBlock',\n      params: JSON.parse(txSerialized),\n    })\n\n    return {\n      hash: result.digest,\n    }\n  }\n}\n","export { XRP } from './XRP'\n\nexport type { XRPTransactionRequest, XRPUnsignedTransaction } from './types'\n","import { createHash } from 'crypto'\n\nimport { encodeAccountID } from 'ripple-address-codec'\nimport { encode as encodeTx } from 'ripple-binary-codec'\nimport { Client } from 'xrpl'\n\nimport { ChainAdapter } from '@chain-adapters/ChainAdapter'\nimport type { ChainSignatureContract } from '@contracts/ChainSignatureContract'\nimport type { HashToSign, RSVSignature, UncompressedPubKeySEC1 } from '@types'\nimport { cryptography } from '@utils'\n\nimport type { XRPTransactionRequest, XRPUnsignedTransaction } from './types'\n\n/**\n * XRP Ledger chain adapter implementation\n *\n * Provides functionality to interact with the XRP Ledger blockchain including\n * balance queries, address derivation, transaction preparation, signing, and broadcasting.\n */\nexport class XRP extends ChainAdapter<\n  XRPTransactionRequest,\n  XRPUnsignedTransaction\n> {\n  private readonly rpcUrl: string\n  private readonly contract: ChainSignatureContract\n  private readonly client: Client\n\n  /**\n   * Creates a new XRP chain adapter instance\n   *\n   * @param params - Configuration parameters\n   * @param params.rpcUrl - XRP Ledger RPC endpoint URL\n   * @param params.contract - Instance of the chain signature contract for MPC operations\n   * @param params.client - Optional XRPL client instance (for testing)\n   */\n  constructor({\n    rpcUrl,\n    contract,\n    client,\n  }: {\n    rpcUrl: string\n    contract: ChainSignatureContract\n    client?: Client\n  }) {\n    super()\n\n    this.rpcUrl = rpcUrl\n    this.contract = contract\n    this.client = client || new Client(this.rpcUrl)\n  }\n\n  /**\n   * Retrieves the XRP balance for a given address\n   *\n   * @param address - The XRP address to query\n   * @returns Promise resolving to balance information with amount in drops and decimal places\n   * @throws Error if the balance query fails for reasons other than account not found\n   */\n  async getBalance(\n    address: string\n  ): Promise<{ balance: bigint; decimals: number }> {\n    try {\n      await this.client.connect()\n\n      const response = await this.client.request({\n        command: 'account_info',\n        account: address,\n        ledger_index: 'validated',\n      })\n\n      const balance = BigInt(String(response?.result?.account_data?.Balance))\n\n      return {\n        balance: balance || 0n,\n        decimals: 6,\n      }\n    } catch (error: any) {\n      // Handle account not found errors\n      if (\n        error?.data?.error === 'actNotFound' ||\n        error?.message?.includes('Account not found') ||\n        error?.data?.error_message?.includes('Account not found')\n      ) {\n        return {\n          balance: 0n,\n          decimals: 6,\n        }\n      }\n\n      console.error('Failed to fetch XRP balance:', error)\n      throw new Error('Failed to fetch XRP balance')\n    } finally {\n      // Always disconnect in finally block to ensure cleanup\n      try {\n        await this.client.disconnect()\n      } catch (disconnectError) {\n        console.warn('Error disconnecting XRP client:', disconnectError)\n      }\n    }\n  }\n\n  /**\n   * Derives an XRP address and compressed public key from the given path and predecessor\n   *\n   * @param predecessor - The predecessor for key derivation\n   * @param path - The derivation path\n   * @returns Promise resolving to the derived address and compressed public key\n   * @throws Error if public key derivation fails\n   */\n  async deriveAddressAndPublicKey(\n    predecessor: string,\n    path: string\n  ): Promise<{ address: string; publicKey: string }> {\n    const uncompressedPubKey = await this.contract.getDerivedPublicKey({\n      path,\n      predecessor,\n    })\n\n    if (!uncompressedPubKey) {\n      throw new Error('Failed to get derived secp256k1 public key')\n    }\n\n    const compressedPubKey = cryptography.compressPubKey(\n      uncompressedPubKey as UncompressedPubKeySEC1\n    )\n\n    const address = this.deriveXRPAddress(compressedPubKey)\n\n    return {\n      address,\n      publicKey: compressedPubKey,\n    }\n  }\n\n  /**\n   * Derives an XRP address from a compressed secp256k1 public key\n   *\n   * @param publicKeyHex - The compressed secp256k1 public key in hex format (66 chars: 02/03 + 64)\n   * @returns The XRP address encoded using ripple-address-codec\n   */\n  private deriveXRPAddress(publicKeyHex: string): string {\n    const publicKeyBuffer = Buffer.from(publicKeyHex, 'hex')\n    const sha256Hash = createHash('sha256').update(publicKeyBuffer).digest()\n    const ripemd160Hash = createHash('ripemd160').update(sha256Hash).digest()\n    const address = encodeAccountID(ripemd160Hash)\n\n    return address\n  }\n\n  /**\n   * Serializes an XRP unsigned transaction to a JSON string\n   *\n   * @param transaction - The unsigned transaction to serialize\n   * @returns JSON string representation of the transaction\n   */\n  serializeTransaction(transaction: XRPUnsignedTransaction): string {\n    return JSON.stringify(transaction)\n  }\n\n  /**\n   * Deserializes a JSON string back to an XRP unsigned transaction\n   *\n   * @param serialized - The JSON string to deserialize\n   * @returns The deserialized unsigned transaction\n   */\n  deserializeTransaction(serialized: string): XRPUnsignedTransaction {\n    return JSON.parse(serialized)\n  }\n\n  /**\n   * Prepares an XRP transaction for signing by autofilling required fields and generating signing hash\n   *\n   * @param transactionRequest - The transaction request containing payment details\n   * @returns Promise resolving to the prepared unsigned transaction and hash to sign\n   * @throws Error if transaction preparation fails\n   */\n  async prepareTransactionForSigning(\n    transactionRequest: XRPTransactionRequest\n  ): Promise<{\n    transaction: XRPUnsignedTransaction\n    hashesToSign: HashToSign[]\n  }> {\n    try {\n      await this.client.connect()\n\n      const signingPubKey = transactionRequest.publicKey\n      const prepared = await this.client.autofill({\n        TransactionType: 'Payment',\n        Account: transactionRequest.from,\n        Destination: transactionRequest.to,\n        Amount: transactionRequest.amount,\n        SigningPubKey: signingPubKey.toUpperCase(),\n      })\n\n      // Don't disconnect here - allow connection reuse\n\n      const unsignedTx: XRPUnsignedTransaction = {\n        transaction: prepared as any,\n        signingPubKey,\n      }\n\n      const encodedTx = encodeTx(prepared)\n\n      const signingPrefix = new Uint8Array([0x53, 0x54, 0x58, 0x00])\n      const encodedBytes = new Uint8Array(Buffer.from(encodedTx, 'hex'))\n\n      const signingData = new Uint8Array(\n        signingPrefix.length + encodedBytes.length\n      )\n      signingData.set(signingPrefix, 0)\n      signingData.set(encodedBytes, signingPrefix.length)\n\n      const hash = createHash('sha512').update(signingData).digest()\n      const signingHash = new Uint8Array(hash.subarray(0, 32))\n\n      return {\n        transaction: unsignedTx,\n        hashesToSign: [signingHash],\n      }\n    } catch (error) {\n      console.error('Failed to prepare XRP transaction for signing:', error)\n      throw new Error('Failed to prepare XRP transaction for signing')\n    }\n  }\n\n  /**\n   * Finalizes transaction signing by applying RSV signatures to the prepared transaction\n   *\n   * @param params - Object containing the unsigned transaction and RSV signatures\n   * @param params.transaction - The unsigned transaction to sign\n   * @param params.rsvSignatures - Array of RSV signatures (only first signature is used)\n   * @returns JSON string of the signed transaction ready for broadcast\n   * @throws Error if no signatures are provided\n   */\n  finalizeTransactionSigning({\n    transaction,\n    rsvSignatures,\n  }: {\n    transaction: XRPUnsignedTransaction\n    rsvSignatures: RSVSignature[]\n  }): string {\n    if (rsvSignatures.length === 0) {\n      throw new Error('Invalid signatures provided')\n    }\n\n    const signature = rsvSignatures[0]\n\n    const derSignature = this.generateTxnSignature(\n      signature.r,\n      signature.s,\n      signature.v\n    )\n\n    const signedTransaction = {\n      ...transaction.transaction,\n      TxnSignature: derSignature,\n      SigningPubKey: transaction.signingPubKey.toUpperCase(),\n    }\n\n    return JSON.stringify(signedTransaction)\n  }\n\n  /**\n   * Generates a DER-encoded transaction signature from RSV signature components\n   *\n   * @param r - The R component of the signature in hex\n   * @param s - The S component of the signature in hex\n   * @param v - The V component of the signature (recovery ID)\n   * @returns DER-encoded signature in uppercase hex format\n   */\n  generateTxnSignature(r: string, s: string, v: number): string {\n    const rBuf = Buffer.from(r, 'hex')\n    const sBuf = Buffer.from(s, 'hex')\n    let rVal = rBuf\n    if (rBuf[0] > 0x7f) {\n      rVal = Buffer.concat([Buffer.from([0x00]), rBuf])\n    }\n\n    let sVal = sBuf\n    if (sBuf[0] > 0x7f) {\n      sVal = Buffer.concat([Buffer.from([0x00]), sBuf])\n    }\n\n    const totalLength = 2 + rVal.length + 2 + sVal.length\n\n    const derSignature = Buffer.alloc(2 + totalLength)\n    let offset = 0\n\n    derSignature.writeUInt8(0x30, offset++)\n    derSignature.writeUInt8(totalLength, offset++)\n    derSignature.writeUInt8(0x02, offset++)\n    derSignature.writeUInt8(rVal.length, offset++)\n    rVal.copy(derSignature, offset)\n    offset += rVal.length\n\n    derSignature.writeUInt8(0x02, offset++)\n    derSignature.writeUInt8(sVal.length, offset++)\n    sVal.copy(derSignature, offset)\n\n    return derSignature.toString('hex').toUpperCase()\n  }\n\n  /**\n   * Broadcasts a signed XRP transaction to the network\n   *\n   * @param txSerialized - JSON string of the signed transaction\n   * @returns Promise resolving to the transaction hash\n   * @throws Error if transaction submission fails or is rejected by the network\n   */\n  async broadcastTx(txSerialized: string): Promise<{ hash: string }> {\n    try {\n      await this.client.connect()\n\n      const transaction = JSON.parse(txSerialized) as Record<string, unknown>\n\n      const txBlob = encodeTx(transaction)\n      const response = await this.client.submit(txBlob)\n\n      await this.client.disconnect()\n\n      if (\n        response.result.engine_result === 'tesSUCCESS' ||\n        response.result.engine_result === 'terQUEUED'\n      ) {\n        const txHash = response.result.tx_json?.hash\n        if (!txHash) {\n          throw new Error('Transaction submitted but no hash received')\n        }\n        return { hash: txHash }\n      } else {\n        throw new Error(\n          `Transaction failed: ${response.result.engine_result} - ${response.result.engine_result === 'terQUEUED' ? 'Transaction is queued' : response.result.engine_result}`\n        )\n      }\n    } catch (error) {\n      console.error('Failed to broadcast XRP transaction:', error)\n      throw new Error('Failed to broadcast XRP transaction')\n    }\n  }\n}\n","// TODO: fix signAndSend\n// import * as signAndSend from './signAndSend'\nimport * as transaction from './transaction'\nexport * from './ChainSignatureContract'\n\nconst utils = {\n  transaction,\n  // signAndSend,\n}\n\nexport { utils }\n","import {\n  type RSVSignature,\n  type MPCSignature,\n  type Ed25519Signature,\n} from '@types'\nimport { cryptography } from '@utils'\n\nexport const responseToMpcSignature = ({\n  signature,\n}: {\n  signature: MPCSignature\n}): RSVSignature | Ed25519Signature | undefined => {\n  if (\n    'scheme' in signature &&\n    signature.scheme === 'Ed25519' &&\n    'signature' in signature\n  ) {\n    return signature as Ed25519Signature\n  }\n  if (signature) {\n    return cryptography.toRSV(signature)\n  } else {\n    return undefined\n  }\n}\n","export const NEAR_MAX_GAS = '300000000000000'\nexport const DONT_CARE_ACCOUNT_ID = 'dontcare'\n","import { FailoverRpcProvider, JsonRpcProvider, Provider } from '@near-js/providers'\nimport { type Action, actionCreators } from '@near-js/transactions'\nimport { type FinalExecutionOutcome } from '@near-js/types'\nimport { getTransactionLastResult } from '@near-js/utils'\nimport {\n  najToUncompressedPubKeySEC1,\n  uint8ArrayToHex,\n} from '@utils/cryptography'\n\nimport {\n  type RSVSignature,\n  type UncompressedPubKeySEC1,\n  type NajPublicKey,\n  type MPCSignature,\n} from '@types'\n\nimport { NEAR_MAX_GAS } from './constants'\nimport { responseToMpcSignature } from './transaction'\nimport type { NearNetworkIds } from './types'\n\ninterface Transaction {\n  signerId?: string\n  receiverId: string\n  actions: Action[]\n}\n\nexport type HashToSign = number[] | Uint8Array\n\nexport interface SignArgs {\n  payloads: HashToSign[]\n  path: string\n  keyType: 'Eddsa' | 'Ecdsa'\n  signerAccount: {\n    accountId: string\n    signAndSendTransactions: (transactions: {\n      transactions: Transaction[]\n    }) => Promise<FinalExecutionOutcome[]>\n  }\n}\n\nexport class ChainSignatureContract {\n  private readonly contractId: string\n  private readonly networkId: NearNetworkIds\n  private readonly provider: FailoverRpcProvider\n\n  constructor({\n    contractId,\n    networkId,\n    fallbackRpcUrls,\n  }: {\n    contractId: string\n    networkId: NearNetworkIds\n    fallbackRpcUrls?: string[]\n  }) {\n    this.contractId = contractId\n    this.networkId = networkId\n\n    const rpcProviderUrls =\n      fallbackRpcUrls && fallbackRpcUrls.length > 0\n        ? fallbackRpcUrls\n        : [`https://rpc.${this.networkId}.near.org`]\n\n    this.provider = new FailoverRpcProvider(\n      rpcProviderUrls.map((url) => new JsonRpcProvider({ url }) as Provider)\n    )\n  }\n\n  getCurrentSignatureDeposit(): number {\n    return 1\n  }\n\n  async sign({\n    payloads,\n    path,\n    keyType,\n    signerAccount,\n  }: SignArgs): Promise<RSVSignature[]> {\n    const transactions = payloads.map((payload) => ({\n      signerId: signerAccount.accountId,\n      receiverId: this.contractId,\n      actions: [\n        actionCreators.functionCall(\n          'sign',\n          {\n            request: {\n              payload_v2: { [keyType]: uint8ArrayToHex(payload) },\n              path,\n              domain_id: keyType === 'Eddsa' ? 1 : 0,\n            },\n          },\n          BigInt(NEAR_MAX_GAS),\n          BigInt(1)\n        ),\n      ],\n    }))\n\n    const sentTxs = await signerAccount.signAndSendTransactions({\n      transactions,\n    })\n\n    const results = sentTxs.map((tx) =>\n      getTransactionLastResult(tx)\n    ) as MPCSignature[]\n\n    const rsvSignatures = results.map((tx) =>\n      responseToMpcSignature({ signature: tx })\n    )\n\n    return rsvSignatures as RSVSignature[]\n  }\n\n  async getPublicKey(): Promise<UncompressedPubKeySEC1> {\n    const najPubKey = await this.provider.callFunction(\n      this.contractId,\n      'public_key',\n      {}\n    )\n    return najToUncompressedPubKeySEC1(najPubKey as NajPublicKey)\n  }\n\n  async getDerivedPublicKey(args: {\n    path: string\n    predecessor: string\n    IsEd25519?: boolean\n  }): Promise<UncompressedPubKeySEC1 | `Ed25519:${string}`> {\n    const najPubKey = await this.provider.callFunction(\n      this.contractId,\n      'derived_public_key',\n      {\n        path: args.path,\n        predecessor: args.predecessor,\n        domain_id: args.IsEd25519 ? 1 : 0,\n      }\n    )\n    return najToUncompressedPubKeySEC1(najPubKey as NajPublicKey)\n  }\n}\n"]}