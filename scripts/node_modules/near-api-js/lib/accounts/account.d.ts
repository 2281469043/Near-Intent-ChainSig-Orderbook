import { type KeyPairString, PublicKey } from '../crypto/index.js';
import { type Provider } from '../providers/index.js';
import type { RpcTransactionResponse } from '../rpc/types.gen.js';
import { type SignedMessage, type Signer } from '../signers/index.js';
import type { SignDelegateActionReturn } from '../signers/signer.js';
import type { FungibleToken, NativeToken } from '../tokens/index.js';
import { type Action, type DelegateAction, type SignedDelegate, type SignedTransaction } from '../transactions/index.js';
import type { SerializedReturnValue, TxExecutionStatus } from '../types/index.js';
export declare const DEFAULT_WAIT_STATUS: TxExecutionStatus;
export interface AccountState {
    balance: {
        total: bigint;
        usedOnStorage: bigint;
        locked: bigint;
        available: bigint;
    };
    storageUsage: number;
    codeHash: string;
}
export interface CreateTransactionArgs {
    receiverId: string;
    actions: Action[];
    publicKey: string | PublicKey;
}
export interface CreateSignedTransactionArgs {
    receiverId: string;
    actions: Action[];
    signer?: Signer;
}
export interface CreateMetaTransactionArgs {
    receiverId: string;
    actions: Action[];
    blockHeightTtl?: number;
    publicKey: PublicKey | string;
}
export interface CreateSignedMetaTransactionArgs {
    receiverId: string;
    actions: Action[];
    blockHeightTtl?: number;
    signer?: Signer;
}
export interface SignAndSendTransactionArgs {
    receiverId: string;
    actions: Action[];
    waitUntil?: TxExecutionStatus;
    throwOnFailure?: boolean;
    signer?: Signer;
    retries?: number;
}
export interface SignAndSendTransactionsArgs {
    transactions: Array<{
        receiverId: string;
        actions: Action[];
    }>;
    waitUntil?: TxExecutionStatus;
    throwOnFailure?: boolean;
    signer?: Signer;
}
export interface CreateAccountArgs {
    newAccountId: string;
    publicKey: PublicKey | string;
    nearToTransfer?: bigint | string | number;
}
export interface CreateSubAccountArgs {
    accountOrPrefix: string;
    publicKey: PublicKey | string;
    nearToTransfer?: bigint | string | number;
}
export interface AddFunctionAccessKeyArgs {
    publicKey: PublicKey | string;
    contractId: string;
    methodNames?: string[];
    allowance?: bigint | string | number;
}
export interface CallFunctionArgs {
    contractId: string;
    methodName: string;
    args?: Uint8Array | Record<string, any>;
    deposit?: bigint | string | number;
    gas?: bigint | string | number;
    waitUntil?: TxExecutionStatus;
}
export interface SignNep413MessageArgs {
    message: string;
    recipient: string;
    nonce: Uint8Array;
    callbackUrl?: string;
}
export interface TransferArgs {
    receiverId: string;
    amount: bigint | string | number;
    token?: NativeToken | FungibleToken;
}
/**
 * This class allows to access common account information.
 * If a {@link Signer} is provider, then the account can
 * be used to perform all common actions such as
 * transferring tokens and calling functions
 */
export declare class Account {
    readonly accountId: string;
    readonly provider: Provider;
    private signer?;
    private readonly nonceManager;
    constructor(accountId: string, provider: Provider | string, signer?: Signer | KeyPairString);
    /**
     * Allows to set the signer used to control the account
     *
     * @param signer holds the private key and can sign Transactions
     */
    setSigner(signer: Signer): void;
    getSigner(): Signer | undefined;
    /**
     * Returns an overview of the account's state, including the account's
     * balance, storage usage, and code hash
     */
    getState(): Promise<AccountState>;
    /**
     * Calls {@link Provider.viewAccessKey} to retrieve information for a
     * specific key in the account
     */
    getAccessKey(publicKey: PublicKey | string): Promise<import("../types/index.js").AccessKeyView>;
    /**
     * Calls {@link Provider.viewAccessKeyList} to retrieve the account's keys
     */
    getAccessKeyList(): Promise<import("../rpc/types.gen.js").AccessKeyList & {
        block_hash: import("../rpc/types.gen.js").CryptoHash;
        block_height: number;
    }>;
    /**
     * Calls {@link Provider.viewContractCode} to retrieve the account's
     * contract code and its hash
     */
    getContractCode(): Promise<import("../types/index.js").ContractCodeView>;
    /**
     * Calls {@link Provider.viewContractState} to retrieve the keys and values
     * stored on the account's contract
     */
    getContractState(prefix?: string): Promise<import("../rpc/types.gen.js").ViewStateResult & {
        block_hash: import("../rpc/types.gen.js").CryptoHash;
        block_height: number;
    }>;
    /**
     * Create a transaction that can be later signed with a {@link Signer}
     *
     * @param options Transaction options
     * @param options.receiverId Account against which to perform the actions
     * @param options.actions Actions to perform
     * @param options.publicKey The public part of the key that will be used to sign the transaction
     */
    createTransaction({ receiverId, actions, publicKey }: CreateTransactionArgs): Promise<import("../transactions/schema.js").Transaction>;
    /**
     * Create a signed transaction ready to be broadcast by a {@link Provider}
     */
    createSignedTransaction({ receiverId, actions, signer, }: CreateSignedTransactionArgs): Promise<SignedTransaction>;
    /**
     * Create a meta transaction ready to be signed by a {@link Signer}
     *
     * @param options Meta transaction options
     * @param options.receiverId NEAR account receiving the transaction
     * @param options.actions list of actions to perform as part of the meta transaction
     * @param options.blockHeightTtl number of blocks after which a meta transaction will expire if not processed
     */
    createMetaTransaction({ receiverId, actions, blockHeightTtl, publicKey, }: CreateMetaTransactionArgs): Promise<DelegateAction>;
    /**
     * Create a signed MetaTransaction that can be broadcasted to a relayer
     *
     * @param options Signed meta transaction options
     * @param options.receiverId NEAR account receiving the transaction
     * @param options.actions list of actions to perform as part of the meta transaction
     * @param options.blockHeightTtl number of blocks after which a meta transaction will expire if not processed
     */
    createSignedMetaTransaction({ receiverId, actions, blockHeightTtl, signer, }: CreateSignedMetaTransactionArgs): Promise<SignDelegateActionReturn>;
    /**
     * Creates a transaction, signs it and broadcast it to the network
     *
     * @param options Sign and send transaction options
     * @param options.receiverId The NEAR account ID of the transaction receiver.
     * @param options.actions The list of actions to be performed in the transaction.
     * @param options.throwOnFailure Whether to throw an error if the transaction fails.
     *
     */
    signAndSendTransaction({ receiverId, actions, waitUntil, throwOnFailure, signer, retries, }: SignAndSendTransactionArgs): Promise<RpcTransactionResponse>;
    signAndSendTransactions({ transactions, waitUntil, throwOnFailure, signer, }: SignAndSendTransactionsArgs): Promise<RpcTransactionResponse[]>;
    /**
     * Creates a new NEAR account with a given ID and public key.
     *
     * This method can create two types of accounts:
     *
     * 1. Top-level accounts of the form `name.tla` (e.g., `bob.near`):
     *
     * 2. Sub-accounts of the current account (e.g., `sub.ana.near`):
     *    - The new account ID must end with the current account ID
     *    - Example: If your account is `ana.near`, you can create `sub.ana.near`
     *
     * @param options Account creation options
     * @param options.newAccountId the new account to create (e.g. bob.near or sub.ana.near)
     * @param options.publicKey the public part of the key that will control the account
     * @param options.nearToTransfer how much NEAR to transfer to the account in yoctoNEAR (default: 0)
     *
     */
    createAccount({ newAccountId, publicKey, nearToTransfer }: CreateAccountArgs): Promise<RpcTransactionResponse>;
    /**
     * Creates a sub account of this account. For example, if the account is
     * ana.near, you can create sub.ana.near.
     *
     * @param options Sub-account creation options
     * @param options.accountOrPrefix a prefix (e.g. `sub`) or the full sub-account (`sub.ana.near`)
     * @param options.publicKey the public part of the key that will control the account
     * @param options.nearToTransfer how much NEAR to transfer to the account (default: 0)
     *
     */
    createSubAccount({ accountOrPrefix, publicKey, nearToTransfer }: CreateSubAccountArgs): Promise<RpcTransactionResponse>;
    /**
     * Deletes the account, transferring all remaining NEAR to a beneficiary
     * account
     *
     * Important: Deleting an account does not transfer FTs or NFTs
     *
     * @param beneficiaryId Will receive the account's remaining balance
     */
    deleteAccount(beneficiaryId: string): Promise<RpcTransactionResponse>;
    /**
     * Deploy a smart contract in the account
     *
     * @param code The compiled contract code bytes
     */
    deployContract(code: Uint8Array): Promise<RpcTransactionResponse>;
    /**
     * Deploy a global contract that can be reused by multiple accounts
     *
     * @param code The compiled contract code bytes
     * @param deployMode Deploy mode - "codeHash" for immutable contracts, "accountId" for updateable contracts
     */
    deployGlobalContract(code: Uint8Array, deployMode: 'codeHash' | 'accountId'): Promise<RpcTransactionResponse>;
    /**
     * Use a previously deployed global contract on this account
     *
     * @param contractIdentifier The global contract identifier - either { accountId: string } or { codeHash: string | Uint8Array }
     */
    useGlobalContract(contractIdentifier: {
        accountId: string;
    } | {
        codeHash: string | Uint8Array;
    }): Promise<RpcTransactionResponse>;
    /**
     *
     * @param options
     * @param options.publicKey The key to add to the account
     * @param options.contractId The contract that this key can call
     * @param options.methodNames The methods this key is allowed to call
     * @param options.allowance The amount of NEAR this key can expend in gas
     * @returns
     */
    addFunctionCallAccessKey({ publicKey, contractId, methodNames, allowance, }: AddFunctionAccessKeyArgs): Promise<RpcTransactionResponse>;
    /**
     * Add a full access key to the account
     *
     * @param publicKey The public key to be added
     */
    addFullAccessKey(publicKey: PublicKey | string): Promise<RpcTransactionResponse>;
    /**
     * @param publicKey The public key to be deleted
     */
    deleteKey(publicKey: PublicKey | string): Promise<RpcTransactionResponse>;
    /**
     * Call a function on a smart contract and return parsed transaction result
     *
     * @param params Call function parameters
     * @param params.contractId The contract in which to call the function
     * @param params.methodName The method that will be called
     * @param params.args Arguments, either as a valid JSON Object or a raw Uint8Array
     * @param params.deposit (optional) Amount of NEAR Tokens to attach to the call (default 0)
     * @param params.gas (optional) Amount of GAS to use attach to the call (default 30TGas)
     * @param params.waitUntil (optional) Transaction finality to wait for (default INCLUDED_FINAL)
     * @returns
     */
    callFunction<T extends SerializedReturnValue>(params: CallFunctionArgs): Promise<T>;
    /**
     * Call a function on a smart contract and return raw transaction outcome
     *
     * @param params Call function parameters
     * @param params.contractId The contract in which to call the function
     * @param params.methodName The method that will be called
     * @param params.args Arguments, either as a valid JSON Object or a raw Uint8Array
     * @param params.deposit (optional) Amount of NEAR Tokens to attach to the call (default 0)
     * @param params.gas (optional) Amount of GAS to use attach to the call (default 30TGas)
     * @param params.waitUntil (optional) Transaction finality to wait for (default INCLUDED_FINAL)
     */
    callFunctionRaw({ contractId, methodName, args, deposit, gas, waitUntil, }: CallFunctionArgs): Promise<RpcTransactionResponse>;
    /**
     * This function simply calls the `signNep413Message` method of the Signer
     *
     * @deprecated This method is deprecated and will be removed in future versions. Please use `signMessage` from `near-api-js/nep413` to sign NEP-413 messages.
     *
     * @param args Nep413 message signing arguments
     * @param args.message The message to be signed (e.g. "authenticating")
     * @param args.recipient Who will receive the message (e.g. auth.app.com)
     * @param args.nonce A challenge sent by the recipient
     * @param args.callbackUrl (optional) Deprecated parameter used only by browser wallets
     * @returns
     */
    signNep413Message({ message, recipient, nonce, callbackUrl, }: SignNep413MessageArgs): Promise<SignedMessage>;
    /**
     *
     * @param token The token to check the balance of. Defaults to Native NEAR.
     * @returns The available balance of the account in units (e.g. yoctoNEAR).
     */
    getBalance(token?: NativeToken | FungibleToken): Promise<bigint>;
    /**
     * Relay a meta-transaction signed by a different account
     *
     * @param signedDelegate The signed delegate action to relay
     * @returns The transaction response from the relayed meta-transaction
     */
    relayMetaTransaction(signedDelegate: SignedDelegate): Promise<RpcTransactionResponse>;
    /**
     * Transfers a token to the specified receiver.
     *
     * Supports sending either the native NEAR token or any supported Fungible Token (FT).
     *
     * @param options Transfer options
     * @param options.amount - The amount of tokens to transfer in units (e.g. yoctoNEAR).
     * @param options.receiverId - The NEAR account ID of the receiver.
     * @param options.token - The token to transfer. Defaults to Native NEAR.
     *
     */
    transfer({ receiverId, amount, token }: TransferArgs): Promise<RpcTransactionResponse>;
}
